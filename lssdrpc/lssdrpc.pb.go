// Code generated by protoc-gen-go. DO NOT EDIT.
// source: lssdrpc.proto

package lssdrpc

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type OrderSide int32

const (
	OrderSide_buy  OrderSide = 0
	OrderSide_sell OrderSide = 1
)

var OrderSide_name = map[int32]string{
	0: "buy",
	1: "sell",
}

var OrderSide_value = map[string]int32{
	"buy":  0,
	"sell": 1,
}

func (x OrderSide) String() string {
	return proto.EnumName(OrderSide_name, int32(x))
}

func (OrderSide) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_197ef81533ed7ae1, []int{0}
}

type SwapSuccess_Role int32

const (
	SwapSuccess_TAKER SwapSuccess_Role = 0
	SwapSuccess_MAKER SwapSuccess_Role = 1
)

var SwapSuccess_Role_name = map[int32]string{
	0: "TAKER",
	1: "MAKER",
}

var SwapSuccess_Role_value = map[string]int32{
	"TAKER": 0,
	"MAKER": 1,
}

func (x SwapSuccess_Role) String() string {
	return proto.EnumName(SwapSuccess_Role_name, int32(x))
}

func (SwapSuccess_Role) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_197ef81533ed7ae1, []int{18, 0}
}

// A non-negative Big Integer represented as string, like "100000000"
type BigInteger struct {
	Value                string   `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BigInteger) Reset()         { *m = BigInteger{} }
func (m *BigInteger) String() string { return proto.CompactTextString(m) }
func (*BigInteger) ProtoMessage()    {}
func (*BigInteger) Descriptor() ([]byte, []int) {
	return fileDescriptor_197ef81533ed7ae1, []int{0}
}

func (m *BigInteger) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BigInteger.Unmarshal(m, b)
}
func (m *BigInteger) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BigInteger.Marshal(b, m, deterministic)
}
func (m *BigInteger) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BigInteger.Merge(m, src)
}
func (m *BigInteger) XXX_Size() int {
	return xxx_messageInfo_BigInteger.Size(m)
}
func (m *BigInteger) XXX_DiscardUnknown() {
	xxx_messageInfo_BigInteger.DiscardUnknown(m)
}

var xxx_messageInfo_BigInteger proto.InternalMessageInfo

func (m *BigInteger) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

type AddCurrencyRequest struct {
	// the currency, like XSN or LTC
	Currency string `protobuf:"bytes,1,opt,name=currency,proto3" json:"currency,omitempty"`
	// the address:port allowing lssd to connect to this currency lnd, like "localhost:10001"
	// right now, it is assumed that the bot runs on the same network than lssd, so, there is
	// no support for authentication.
	LndChannel string `protobuf:"bytes,2,opt,name=lndChannel,proto3" json:"lndChannel,omitempty"`
	// the tls certificate used by lnd, so that lssd can be sure it's connecting to the right lnd
	//
	// Types that are valid to be assigned to TlsCert:
	//	*AddCurrencyRequest_CertPath
	//	*AddCurrencyRequest_RawCert
	TlsCert              isAddCurrencyRequest_TlsCert `protobuf_oneof:"tlsCert"`
	XXX_NoUnkeyedLiteral struct{}                     `json:"-"`
	XXX_unrecognized     []byte                       `json:"-"`
	XXX_sizecache        int32                        `json:"-"`
}

func (m *AddCurrencyRequest) Reset()         { *m = AddCurrencyRequest{} }
func (m *AddCurrencyRequest) String() string { return proto.CompactTextString(m) }
func (*AddCurrencyRequest) ProtoMessage()    {}
func (*AddCurrencyRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_197ef81533ed7ae1, []int{1}
}

func (m *AddCurrencyRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AddCurrencyRequest.Unmarshal(m, b)
}
func (m *AddCurrencyRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AddCurrencyRequest.Marshal(b, m, deterministic)
}
func (m *AddCurrencyRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddCurrencyRequest.Merge(m, src)
}
func (m *AddCurrencyRequest) XXX_Size() int {
	return xxx_messageInfo_AddCurrencyRequest.Size(m)
}
func (m *AddCurrencyRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AddCurrencyRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AddCurrencyRequest proto.InternalMessageInfo

func (m *AddCurrencyRequest) GetCurrency() string {
	if m != nil {
		return m.Currency
	}
	return ""
}

func (m *AddCurrencyRequest) GetLndChannel() string {
	if m != nil {
		return m.LndChannel
	}
	return ""
}

type isAddCurrencyRequest_TlsCert interface {
	isAddCurrencyRequest_TlsCert()
}

type AddCurrencyRequest_CertPath struct {
	CertPath string `protobuf:"bytes,3,opt,name=certPath,proto3,oneof"`
}

type AddCurrencyRequest_RawCert struct {
	RawCert string `protobuf:"bytes,4,opt,name=rawCert,proto3,oneof"`
}

func (*AddCurrencyRequest_CertPath) isAddCurrencyRequest_TlsCert() {}

func (*AddCurrencyRequest_RawCert) isAddCurrencyRequest_TlsCert() {}

func (m *AddCurrencyRequest) GetTlsCert() isAddCurrencyRequest_TlsCert {
	if m != nil {
		return m.TlsCert
	}
	return nil
}

func (m *AddCurrencyRequest) GetCertPath() string {
	if x, ok := m.GetTlsCert().(*AddCurrencyRequest_CertPath); ok {
		return x.CertPath
	}
	return ""
}

func (m *AddCurrencyRequest) GetRawCert() string {
	if x, ok := m.GetTlsCert().(*AddCurrencyRequest_RawCert); ok {
		return x.RawCert
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*AddCurrencyRequest) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*AddCurrencyRequest_CertPath)(nil),
		(*AddCurrencyRequest_RawCert)(nil),
	}
}

type AddCurrencyResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AddCurrencyResponse) Reset()         { *m = AddCurrencyResponse{} }
func (m *AddCurrencyResponse) String() string { return proto.CompactTextString(m) }
func (*AddCurrencyResponse) ProtoMessage()    {}
func (*AddCurrencyResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_197ef81533ed7ae1, []int{2}
}

func (m *AddCurrencyResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AddCurrencyResponse.Unmarshal(m, b)
}
func (m *AddCurrencyResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AddCurrencyResponse.Marshal(b, m, deterministic)
}
func (m *AddCurrencyResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddCurrencyResponse.Merge(m, src)
}
func (m *AddCurrencyResponse) XXX_Size() int {
	return xxx_messageInfo_AddCurrencyResponse.Size(m)
}
func (m *AddCurrencyResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AddCurrencyResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AddCurrencyResponse proto.InternalMessageInfo

type EnableTradingPairRequest struct {
	PairId               string   `protobuf:"bytes,1,opt,name=pairId,proto3" json:"pairId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EnableTradingPairRequest) Reset()         { *m = EnableTradingPairRequest{} }
func (m *EnableTradingPairRequest) String() string { return proto.CompactTextString(m) }
func (*EnableTradingPairRequest) ProtoMessage()    {}
func (*EnableTradingPairRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_197ef81533ed7ae1, []int{3}
}

func (m *EnableTradingPairRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_EnableTradingPairRequest.Unmarshal(m, b)
}
func (m *EnableTradingPairRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_EnableTradingPairRequest.Marshal(b, m, deterministic)
}
func (m *EnableTradingPairRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EnableTradingPairRequest.Merge(m, src)
}
func (m *EnableTradingPairRequest) XXX_Size() int {
	return xxx_messageInfo_EnableTradingPairRequest.Size(m)
}
func (m *EnableTradingPairRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_EnableTradingPairRequest.DiscardUnknown(m)
}

var xxx_messageInfo_EnableTradingPairRequest proto.InternalMessageInfo

func (m *EnableTradingPairRequest) GetPairId() string {
	if m != nil {
		return m.PairId
	}
	return ""
}

type EnableTradingPairResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EnableTradingPairResponse) Reset()         { *m = EnableTradingPairResponse{} }
func (m *EnableTradingPairResponse) String() string { return proto.CompactTextString(m) }
func (*EnableTradingPairResponse) ProtoMessage()    {}
func (*EnableTradingPairResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_197ef81533ed7ae1, []int{4}
}

func (m *EnableTradingPairResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_EnableTradingPairResponse.Unmarshal(m, b)
}
func (m *EnableTradingPairResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_EnableTradingPairResponse.Marshal(b, m, deterministic)
}
func (m *EnableTradingPairResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EnableTradingPairResponse.Merge(m, src)
}
func (m *EnableTradingPairResponse) XXX_Size() int {
	return xxx_messageInfo_EnableTradingPairResponse.Size(m)
}
func (m *EnableTradingPairResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_EnableTradingPairResponse.DiscardUnknown(m)
}

var xxx_messageInfo_EnableTradingPairResponse proto.InternalMessageInfo

type ListOrdersRequest struct {
	PairId               string   `protobuf:"bytes,1,opt,name=pairId,proto3" json:"pairId,omitempty"`
	IncludeOwnOrders     bool     `protobuf:"varint,2,opt,name=includeOwnOrders,proto3" json:"includeOwnOrders,omitempty"`
	Skip                 uint32   `protobuf:"varint,3,opt,name=skip,proto3" json:"skip,omitempty"`
	Limit                uint32   `protobuf:"varint,4,opt,name=limit,proto3" json:"limit,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListOrdersRequest) Reset()         { *m = ListOrdersRequest{} }
func (m *ListOrdersRequest) String() string { return proto.CompactTextString(m) }
func (*ListOrdersRequest) ProtoMessage()    {}
func (*ListOrdersRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_197ef81533ed7ae1, []int{5}
}

func (m *ListOrdersRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ListOrdersRequest.Unmarshal(m, b)
}
func (m *ListOrdersRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ListOrdersRequest.Marshal(b, m, deterministic)
}
func (m *ListOrdersRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListOrdersRequest.Merge(m, src)
}
func (m *ListOrdersRequest) XXX_Size() int {
	return xxx_messageInfo_ListOrdersRequest.Size(m)
}
func (m *ListOrdersRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListOrdersRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListOrdersRequest proto.InternalMessageInfo

func (m *ListOrdersRequest) GetPairId() string {
	if m != nil {
		return m.PairId
	}
	return ""
}

func (m *ListOrdersRequest) GetIncludeOwnOrders() bool {
	if m != nil {
		return m.IncludeOwnOrders
	}
	return false
}

func (m *ListOrdersRequest) GetSkip() uint32 {
	if m != nil {
		return m.Skip
	}
	return 0
}

func (m *ListOrdersRequest) GetLimit() uint32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

type ListOrdersResponse struct {
	Orders               []*Order `protobuf:"bytes,1,rep,name=orders,proto3" json:"orders,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListOrdersResponse) Reset()         { *m = ListOrdersResponse{} }
func (m *ListOrdersResponse) String() string { return proto.CompactTextString(m) }
func (*ListOrdersResponse) ProtoMessage()    {}
func (*ListOrdersResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_197ef81533ed7ae1, []int{6}
}

func (m *ListOrdersResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ListOrdersResponse.Unmarshal(m, b)
}
func (m *ListOrdersResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ListOrdersResponse.Marshal(b, m, deterministic)
}
func (m *ListOrdersResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListOrdersResponse.Merge(m, src)
}
func (m *ListOrdersResponse) XXX_Size() int {
	return xxx_messageInfo_ListOrdersResponse.Size(m)
}
func (m *ListOrdersResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListOrdersResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListOrdersResponse proto.InternalMessageInfo

func (m *ListOrdersResponse) GetOrders() []*Order {
	if m != nil {
		return m.Orders
	}
	return nil
}

type PlaceOrderRequest struct {
	PairId               string      `protobuf:"bytes,1,opt,name=pairId,proto3" json:"pairId,omitempty"`
	Side                 OrderSide   `protobuf:"varint,2,opt,name=side,proto3,enum=lssdrpc.OrderSide" json:"side,omitempty"`
	Funds                *BigInteger `protobuf:"bytes,3,opt,name=funds,proto3" json:"funds,omitempty"`
	Price                *BigInteger `protobuf:"bytes,4,opt,name=price,proto3" json:"price,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *PlaceOrderRequest) Reset()         { *m = PlaceOrderRequest{} }
func (m *PlaceOrderRequest) String() string { return proto.CompactTextString(m) }
func (*PlaceOrderRequest) ProtoMessage()    {}
func (*PlaceOrderRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_197ef81533ed7ae1, []int{7}
}

func (m *PlaceOrderRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PlaceOrderRequest.Unmarshal(m, b)
}
func (m *PlaceOrderRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PlaceOrderRequest.Marshal(b, m, deterministic)
}
func (m *PlaceOrderRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PlaceOrderRequest.Merge(m, src)
}
func (m *PlaceOrderRequest) XXX_Size() int {
	return xxx_messageInfo_PlaceOrderRequest.Size(m)
}
func (m *PlaceOrderRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_PlaceOrderRequest.DiscardUnknown(m)
}

var xxx_messageInfo_PlaceOrderRequest proto.InternalMessageInfo

func (m *PlaceOrderRequest) GetPairId() string {
	if m != nil {
		return m.PairId
	}
	return ""
}

func (m *PlaceOrderRequest) GetSide() OrderSide {
	if m != nil {
		return m.Side
	}
	return OrderSide_buy
}

func (m *PlaceOrderRequest) GetFunds() *BigInteger {
	if m != nil {
		return m.Funds
	}
	return nil
}

func (m *PlaceOrderRequest) GetPrice() *BigInteger {
	if m != nil {
		return m.Price
	}
	return nil
}

// Outcome of place order, three possible situations
// 1. Order was placed
// 2. Order was placed and matched without going to orderbook
// 3. Place order or swap has failed
type PlaceOrderResponse struct {
	// Types that are valid to be assigned to Outcome:
	//	*PlaceOrderResponse_SwapSuccess
	//	*PlaceOrderResponse_Order
	//	*PlaceOrderResponse_Failure
	Outcome              isPlaceOrderResponse_Outcome `protobuf_oneof:"outcome"`
	XXX_NoUnkeyedLiteral struct{}                     `json:"-"`
	XXX_unrecognized     []byte                       `json:"-"`
	XXX_sizecache        int32                        `json:"-"`
}

func (m *PlaceOrderResponse) Reset()         { *m = PlaceOrderResponse{} }
func (m *PlaceOrderResponse) String() string { return proto.CompactTextString(m) }
func (*PlaceOrderResponse) ProtoMessage()    {}
func (*PlaceOrderResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_197ef81533ed7ae1, []int{8}
}

func (m *PlaceOrderResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PlaceOrderResponse.Unmarshal(m, b)
}
func (m *PlaceOrderResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PlaceOrderResponse.Marshal(b, m, deterministic)
}
func (m *PlaceOrderResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PlaceOrderResponse.Merge(m, src)
}
func (m *PlaceOrderResponse) XXX_Size() int {
	return xxx_messageInfo_PlaceOrderResponse.Size(m)
}
func (m *PlaceOrderResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_PlaceOrderResponse.DiscardUnknown(m)
}

var xxx_messageInfo_PlaceOrderResponse proto.InternalMessageInfo

type isPlaceOrderResponse_Outcome interface {
	isPlaceOrderResponse_Outcome()
}

type PlaceOrderResponse_SwapSuccess struct {
	SwapSuccess *SwapSuccess `protobuf:"bytes,1,opt,name=swapSuccess,proto3,oneof"`
}

type PlaceOrderResponse_Order struct {
	Order *Order `protobuf:"bytes,2,opt,name=order,proto3,oneof"`
}

type PlaceOrderResponse_Failure struct {
	Failure *PlaceOrderFailure `protobuf:"bytes,3,opt,name=failure,proto3,oneof"`
}

func (*PlaceOrderResponse_SwapSuccess) isPlaceOrderResponse_Outcome() {}

func (*PlaceOrderResponse_Order) isPlaceOrderResponse_Outcome() {}

func (*PlaceOrderResponse_Failure) isPlaceOrderResponse_Outcome() {}

func (m *PlaceOrderResponse) GetOutcome() isPlaceOrderResponse_Outcome {
	if m != nil {
		return m.Outcome
	}
	return nil
}

func (m *PlaceOrderResponse) GetSwapSuccess() *SwapSuccess {
	if x, ok := m.GetOutcome().(*PlaceOrderResponse_SwapSuccess); ok {
		return x.SwapSuccess
	}
	return nil
}

func (m *PlaceOrderResponse) GetOrder() *Order {
	if x, ok := m.GetOutcome().(*PlaceOrderResponse_Order); ok {
		return x.Order
	}
	return nil
}

func (m *PlaceOrderResponse) GetFailure() *PlaceOrderFailure {
	if x, ok := m.GetOutcome().(*PlaceOrderResponse_Failure); ok {
		return x.Failure
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*PlaceOrderResponse) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*PlaceOrderResponse_SwapSuccess)(nil),
		(*PlaceOrderResponse_Order)(nil),
		(*PlaceOrderResponse_Failure)(nil),
	}
}

type OrderbookFailure struct {
	PairId               string      `protobuf:"bytes,1,opt,name=pairId,proto3" json:"pairId,omitempty"`
	Funds                *BigInteger `protobuf:"bytes,2,opt,name=funds,proto3" json:"funds,omitempty"`
	FailureReason        string      `protobuf:"bytes,3,opt,name=failureReason,proto3" json:"failureReason,omitempty"`
	RequiredFee          *BigInteger `protobuf:"bytes,4,opt,name=requiredFee,proto3" json:"requiredFee,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *OrderbookFailure) Reset()         { *m = OrderbookFailure{} }
func (m *OrderbookFailure) String() string { return proto.CompactTextString(m) }
func (*OrderbookFailure) ProtoMessage()    {}
func (*OrderbookFailure) Descriptor() ([]byte, []int) {
	return fileDescriptor_197ef81533ed7ae1, []int{9}
}

func (m *OrderbookFailure) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_OrderbookFailure.Unmarshal(m, b)
}
func (m *OrderbookFailure) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_OrderbookFailure.Marshal(b, m, deterministic)
}
func (m *OrderbookFailure) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OrderbookFailure.Merge(m, src)
}
func (m *OrderbookFailure) XXX_Size() int {
	return xxx_messageInfo_OrderbookFailure.Size(m)
}
func (m *OrderbookFailure) XXX_DiscardUnknown() {
	xxx_messageInfo_OrderbookFailure.DiscardUnknown(m)
}

var xxx_messageInfo_OrderbookFailure proto.InternalMessageInfo

func (m *OrderbookFailure) GetPairId() string {
	if m != nil {
		return m.PairId
	}
	return ""
}

func (m *OrderbookFailure) GetFunds() *BigInteger {
	if m != nil {
		return m.Funds
	}
	return nil
}

func (m *OrderbookFailure) GetFailureReason() string {
	if m != nil {
		return m.FailureReason
	}
	return ""
}

func (m *OrderbookFailure) GetRequiredFee() *BigInteger {
	if m != nil {
		return m.RequiredFee
	}
	return nil
}

type PlaceOrderFailure struct {
	// Types that are valid to be assigned to Failure:
	//	*PlaceOrderFailure_SwapFailure
	//	*PlaceOrderFailure_OrderbookFailure
	Failure              isPlaceOrderFailure_Failure `protobuf_oneof:"failure"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *PlaceOrderFailure) Reset()         { *m = PlaceOrderFailure{} }
func (m *PlaceOrderFailure) String() string { return proto.CompactTextString(m) }
func (*PlaceOrderFailure) ProtoMessage()    {}
func (*PlaceOrderFailure) Descriptor() ([]byte, []int) {
	return fileDescriptor_197ef81533ed7ae1, []int{10}
}

func (m *PlaceOrderFailure) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PlaceOrderFailure.Unmarshal(m, b)
}
func (m *PlaceOrderFailure) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PlaceOrderFailure.Marshal(b, m, deterministic)
}
func (m *PlaceOrderFailure) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PlaceOrderFailure.Merge(m, src)
}
func (m *PlaceOrderFailure) XXX_Size() int {
	return xxx_messageInfo_PlaceOrderFailure.Size(m)
}
func (m *PlaceOrderFailure) XXX_DiscardUnknown() {
	xxx_messageInfo_PlaceOrderFailure.DiscardUnknown(m)
}

var xxx_messageInfo_PlaceOrderFailure proto.InternalMessageInfo

type isPlaceOrderFailure_Failure interface {
	isPlaceOrderFailure_Failure()
}

type PlaceOrderFailure_SwapFailure struct {
	SwapFailure *SwapFailure `protobuf:"bytes,1,opt,name=swapFailure,proto3,oneof"`
}

type PlaceOrderFailure_OrderbookFailure struct {
	OrderbookFailure *OrderbookFailure `protobuf:"bytes,2,opt,name=orderbookFailure,proto3,oneof"`
}

func (*PlaceOrderFailure_SwapFailure) isPlaceOrderFailure_Failure() {}

func (*PlaceOrderFailure_OrderbookFailure) isPlaceOrderFailure_Failure() {}

func (m *PlaceOrderFailure) GetFailure() isPlaceOrderFailure_Failure {
	if m != nil {
		return m.Failure
	}
	return nil
}

func (m *PlaceOrderFailure) GetSwapFailure() *SwapFailure {
	if x, ok := m.GetFailure().(*PlaceOrderFailure_SwapFailure); ok {
		return x.SwapFailure
	}
	return nil
}

func (m *PlaceOrderFailure) GetOrderbookFailure() *OrderbookFailure {
	if x, ok := m.GetFailure().(*PlaceOrderFailure_OrderbookFailure); ok {
		return x.OrderbookFailure
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*PlaceOrderFailure) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*PlaceOrderFailure_SwapFailure)(nil),
		(*PlaceOrderFailure_OrderbookFailure)(nil),
	}
}

type CancelOrderRequest struct {
	PairId               string   `protobuf:"bytes,1,opt,name=pairId,proto3" json:"pairId,omitempty"`
	OrderId              string   `protobuf:"bytes,2,opt,name=orderId,proto3" json:"orderId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CancelOrderRequest) Reset()         { *m = CancelOrderRequest{} }
func (m *CancelOrderRequest) String() string { return proto.CompactTextString(m) }
func (*CancelOrderRequest) ProtoMessage()    {}
func (*CancelOrderRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_197ef81533ed7ae1, []int{11}
}

func (m *CancelOrderRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CancelOrderRequest.Unmarshal(m, b)
}
func (m *CancelOrderRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CancelOrderRequest.Marshal(b, m, deterministic)
}
func (m *CancelOrderRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CancelOrderRequest.Merge(m, src)
}
func (m *CancelOrderRequest) XXX_Size() int {
	return xxx_messageInfo_CancelOrderRequest.Size(m)
}
func (m *CancelOrderRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CancelOrderRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CancelOrderRequest proto.InternalMessageInfo

func (m *CancelOrderRequest) GetPairId() string {
	if m != nil {
		return m.PairId
	}
	return ""
}

func (m *CancelOrderRequest) GetOrderId() string {
	if m != nil {
		return m.OrderId
	}
	return ""
}

type CancelOrderResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CancelOrderResponse) Reset()         { *m = CancelOrderResponse{} }
func (m *CancelOrderResponse) String() string { return proto.CompactTextString(m) }
func (*CancelOrderResponse) ProtoMessage()    {}
func (*CancelOrderResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_197ef81533ed7ae1, []int{12}
}

func (m *CancelOrderResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CancelOrderResponse.Unmarshal(m, b)
}
func (m *CancelOrderResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CancelOrderResponse.Marshal(b, m, deterministic)
}
func (m *CancelOrderResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CancelOrderResponse.Merge(m, src)
}
func (m *CancelOrderResponse) XXX_Size() int {
	return xxx_messageInfo_CancelOrderResponse.Size(m)
}
func (m *CancelOrderResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CancelOrderResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CancelOrderResponse proto.InternalMessageInfo

type SubscribeOrdersRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SubscribeOrdersRequest) Reset()         { *m = SubscribeOrdersRequest{} }
func (m *SubscribeOrdersRequest) String() string { return proto.CompactTextString(m) }
func (*SubscribeOrdersRequest) ProtoMessage()    {}
func (*SubscribeOrdersRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_197ef81533ed7ae1, []int{13}
}

func (m *SubscribeOrdersRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SubscribeOrdersRequest.Unmarshal(m, b)
}
func (m *SubscribeOrdersRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SubscribeOrdersRequest.Marshal(b, m, deterministic)
}
func (m *SubscribeOrdersRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubscribeOrdersRequest.Merge(m, src)
}
func (m *SubscribeOrdersRequest) XXX_Size() int {
	return xxx_messageInfo_SubscribeOrdersRequest.Size(m)
}
func (m *SubscribeOrdersRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SubscribeOrdersRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SubscribeOrdersRequest proto.InternalMessageInfo

type OrderUpdate struct {
	// Types that are valid to be assigned to Update:
	//	*OrderUpdate_Order
	//	*OrderUpdate_OrderRemoval
	Update               isOrderUpdate_Update `protobuf_oneof:"update"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *OrderUpdate) Reset()         { *m = OrderUpdate{} }
func (m *OrderUpdate) String() string { return proto.CompactTextString(m) }
func (*OrderUpdate) ProtoMessage()    {}
func (*OrderUpdate) Descriptor() ([]byte, []int) {
	return fileDescriptor_197ef81533ed7ae1, []int{14}
}

func (m *OrderUpdate) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_OrderUpdate.Unmarshal(m, b)
}
func (m *OrderUpdate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_OrderUpdate.Marshal(b, m, deterministic)
}
func (m *OrderUpdate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OrderUpdate.Merge(m, src)
}
func (m *OrderUpdate) XXX_Size() int {
	return xxx_messageInfo_OrderUpdate.Size(m)
}
func (m *OrderUpdate) XXX_DiscardUnknown() {
	xxx_messageInfo_OrderUpdate.DiscardUnknown(m)
}

var xxx_messageInfo_OrderUpdate proto.InternalMessageInfo

type isOrderUpdate_Update interface {
	isOrderUpdate_Update()
}

type OrderUpdate_Order struct {
	Order *Order `protobuf:"bytes,1,opt,name=order,proto3,oneof"`
}

type OrderUpdate_OrderRemoval struct {
	OrderRemoval *Order `protobuf:"bytes,2,opt,name=orderRemoval,proto3,oneof"`
}

func (*OrderUpdate_Order) isOrderUpdate_Update() {}

func (*OrderUpdate_OrderRemoval) isOrderUpdate_Update() {}

func (m *OrderUpdate) GetUpdate() isOrderUpdate_Update {
	if m != nil {
		return m.Update
	}
	return nil
}

func (m *OrderUpdate) GetOrder() *Order {
	if x, ok := m.GetUpdate().(*OrderUpdate_Order); ok {
		return x.Order
	}
	return nil
}

func (m *OrderUpdate) GetOrderRemoval() *Order {
	if x, ok := m.GetUpdate().(*OrderUpdate_OrderRemoval); ok {
		return x.OrderRemoval
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*OrderUpdate) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*OrderUpdate_Order)(nil),
		(*OrderUpdate_OrderRemoval)(nil),
	}
}

type Order struct {
	PairId  string `protobuf:"bytes,1,opt,name=pairId,proto3" json:"pairId,omitempty"`
	OrderId string `protobuf:"bytes,2,opt,name=orderId,proto3" json:"orderId,omitempty"`
	// The price of the order in satoshis.
	Price *BigInteger `protobuf:"bytes,3,opt,name=price,proto3" json:"price,omitempty"`
	// The funds of the order in satoshis.
	Funds *BigInteger `protobuf:"bytes,4,opt,name=funds,proto3" json:"funds,omitempty"`
	// The epoch time when this order was created.
	CreatedAt uint64 `protobuf:"varint,5,opt,name=createdAt,proto3" json:"createdAt,omitempty"`
	// Whether this order is a buy or sell
	Side OrderSide `protobuf:"varint,6,opt,name=side,proto3,enum=lssdrpc.OrderSide" json:"side,omitempty"`
	// Whether this order is a local own order or a remote peer order.
	IsOwnOrder           bool     `protobuf:"varint,7,opt,name=isOwnOrder,proto3" json:"isOwnOrder,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Order) Reset()         { *m = Order{} }
func (m *Order) String() string { return proto.CompactTextString(m) }
func (*Order) ProtoMessage()    {}
func (*Order) Descriptor() ([]byte, []int) {
	return fileDescriptor_197ef81533ed7ae1, []int{15}
}

func (m *Order) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Order.Unmarshal(m, b)
}
func (m *Order) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Order.Marshal(b, m, deterministic)
}
func (m *Order) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Order.Merge(m, src)
}
func (m *Order) XXX_Size() int {
	return xxx_messageInfo_Order.Size(m)
}
func (m *Order) XXX_DiscardUnknown() {
	xxx_messageInfo_Order.DiscardUnknown(m)
}

var xxx_messageInfo_Order proto.InternalMessageInfo

func (m *Order) GetPairId() string {
	if m != nil {
		return m.PairId
	}
	return ""
}

func (m *Order) GetOrderId() string {
	if m != nil {
		return m.OrderId
	}
	return ""
}

func (m *Order) GetPrice() *BigInteger {
	if m != nil {
		return m.Price
	}
	return nil
}

func (m *Order) GetFunds() *BigInteger {
	if m != nil {
		return m.Funds
	}
	return nil
}

func (m *Order) GetCreatedAt() uint64 {
	if m != nil {
		return m.CreatedAt
	}
	return 0
}

func (m *Order) GetSide() OrderSide {
	if m != nil {
		return m.Side
	}
	return OrderSide_buy
}

func (m *Order) GetIsOwnOrder() bool {
	if m != nil {
		return m.IsOwnOrder
	}
	return false
}

type SubscribeSwapsRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SubscribeSwapsRequest) Reset()         { *m = SubscribeSwapsRequest{} }
func (m *SubscribeSwapsRequest) String() string { return proto.CompactTextString(m) }
func (*SubscribeSwapsRequest) ProtoMessage()    {}
func (*SubscribeSwapsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_197ef81533ed7ae1, []int{16}
}

func (m *SubscribeSwapsRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SubscribeSwapsRequest.Unmarshal(m, b)
}
func (m *SubscribeSwapsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SubscribeSwapsRequest.Marshal(b, m, deterministic)
}
func (m *SubscribeSwapsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubscribeSwapsRequest.Merge(m, src)
}
func (m *SubscribeSwapsRequest) XXX_Size() int {
	return xxx_messageInfo_SubscribeSwapsRequest.Size(m)
}
func (m *SubscribeSwapsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SubscribeSwapsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SubscribeSwapsRequest proto.InternalMessageInfo

type SwapResult struct {
	// Types that are valid to be assigned to Value:
	//	*SwapResult_Success
	//	*SwapResult_Failure
	Value                isSwapResult_Value `protobuf_oneof:"value"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *SwapResult) Reset()         { *m = SwapResult{} }
func (m *SwapResult) String() string { return proto.CompactTextString(m) }
func (*SwapResult) ProtoMessage()    {}
func (*SwapResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_197ef81533ed7ae1, []int{17}
}

func (m *SwapResult) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SwapResult.Unmarshal(m, b)
}
func (m *SwapResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SwapResult.Marshal(b, m, deterministic)
}
func (m *SwapResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SwapResult.Merge(m, src)
}
func (m *SwapResult) XXX_Size() int {
	return xxx_messageInfo_SwapResult.Size(m)
}
func (m *SwapResult) XXX_DiscardUnknown() {
	xxx_messageInfo_SwapResult.DiscardUnknown(m)
}

var xxx_messageInfo_SwapResult proto.InternalMessageInfo

type isSwapResult_Value interface {
	isSwapResult_Value()
}

type SwapResult_Success struct {
	Success *SwapSuccess `protobuf:"bytes,1,opt,name=success,proto3,oneof"`
}

type SwapResult_Failure struct {
	Failure *SwapFailure `protobuf:"bytes,2,opt,name=failure,proto3,oneof"`
}

func (*SwapResult_Success) isSwapResult_Value() {}

func (*SwapResult_Failure) isSwapResult_Value() {}

func (m *SwapResult) GetValue() isSwapResult_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *SwapResult) GetSuccess() *SwapSuccess {
	if x, ok := m.GetValue().(*SwapResult_Success); ok {
		return x.Success
	}
	return nil
}

func (m *SwapResult) GetFailure() *SwapFailure {
	if x, ok := m.GetValue().(*SwapResult_Failure); ok {
		return x.Failure
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*SwapResult) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*SwapResult_Success)(nil),
		(*SwapResult_Failure)(nil),
	}
}

type SwapSuccess struct {
	// Order id assigned by orderbook
	OrderId string `protobuf:"bytes,1,opt,name=orderId,proto3" json:"orderId,omitempty"`
	// The trading pair that the swap is for.
	PairId string `protobuf:"bytes,2,opt,name=pairId,proto3" json:"pairId,omitempty"`
	// The order funds that was swapped.
	Funds *BigInteger `protobuf:"bytes,3,opt,name=funds,proto3" json:"funds,omitempty"`
	// The hex-encoded payment hash for the swap.
	RHash string `protobuf:"bytes,4,opt,name=rHash,proto3" json:"rHash,omitempty"`
	// The amount received denominated in satoshis.
	AmountReceived *BigInteger `protobuf:"bytes,5,opt,name=amountReceived,proto3" json:"amountReceived,omitempty"`
	// The amount sent denominated in satoshis.
	AmountSent *BigInteger `protobuf:"bytes,6,opt,name=amountSent,proto3" json:"amountSent,omitempty"`
	// Our role in the swap, either MAKER or TAKER.
	Role SwapSuccess_Role `protobuf:"varint,7,opt,name=role,proto3,enum=lssdrpc.SwapSuccess_Role" json:"role,omitempty"`
	// The ticker symbol of the currency received.
	CurrencyReceived string `protobuf:"bytes,8,opt,name=currencyReceived,proto3" json:"currencyReceived,omitempty"`
	// The ticker symbol of the currency sent.
	CurrencySent string `protobuf:"bytes,9,opt,name=currencySent,proto3" json:"currencySent,omitempty"`
	// The hex-encoded preimage.
	RPreimage string `protobuf:"bytes,10,opt,name=rPreimage,proto3" json:"rPreimage,omitempty"`
	// The price used for the swap.
	Price                *BigInteger `protobuf:"bytes,11,opt,name=price,proto3" json:"price,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *SwapSuccess) Reset()         { *m = SwapSuccess{} }
func (m *SwapSuccess) String() string { return proto.CompactTextString(m) }
func (*SwapSuccess) ProtoMessage()    {}
func (*SwapSuccess) Descriptor() ([]byte, []int) {
	return fileDescriptor_197ef81533ed7ae1, []int{18}
}

func (m *SwapSuccess) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SwapSuccess.Unmarshal(m, b)
}
func (m *SwapSuccess) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SwapSuccess.Marshal(b, m, deterministic)
}
func (m *SwapSuccess) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SwapSuccess.Merge(m, src)
}
func (m *SwapSuccess) XXX_Size() int {
	return xxx_messageInfo_SwapSuccess.Size(m)
}
func (m *SwapSuccess) XXX_DiscardUnknown() {
	xxx_messageInfo_SwapSuccess.DiscardUnknown(m)
}

var xxx_messageInfo_SwapSuccess proto.InternalMessageInfo

func (m *SwapSuccess) GetOrderId() string {
	if m != nil {
		return m.OrderId
	}
	return ""
}

func (m *SwapSuccess) GetPairId() string {
	if m != nil {
		return m.PairId
	}
	return ""
}

func (m *SwapSuccess) GetFunds() *BigInteger {
	if m != nil {
		return m.Funds
	}
	return nil
}

func (m *SwapSuccess) GetRHash() string {
	if m != nil {
		return m.RHash
	}
	return ""
}

func (m *SwapSuccess) GetAmountReceived() *BigInteger {
	if m != nil {
		return m.AmountReceived
	}
	return nil
}

func (m *SwapSuccess) GetAmountSent() *BigInteger {
	if m != nil {
		return m.AmountSent
	}
	return nil
}

func (m *SwapSuccess) GetRole() SwapSuccess_Role {
	if m != nil {
		return m.Role
	}
	return SwapSuccess_TAKER
}

func (m *SwapSuccess) GetCurrencyReceived() string {
	if m != nil {
		return m.CurrencyReceived
	}
	return ""
}

func (m *SwapSuccess) GetCurrencySent() string {
	if m != nil {
		return m.CurrencySent
	}
	return ""
}

func (m *SwapSuccess) GetRPreimage() string {
	if m != nil {
		return m.RPreimage
	}
	return ""
}

func (m *SwapSuccess) GetPrice() *BigInteger {
	if m != nil {
		return m.Price
	}
	return nil
}

type SwapFailure struct {
	// Order id assigned by orderbook
	OrderId string `protobuf:"bytes,1,opt,name=orderId,proto3" json:"orderId,omitempty"`
	// The trading pair that the swap is for.
	PairId string `protobuf:"bytes,2,opt,name=pairId,proto3" json:"pairId,omitempty"`
	// The order funds that was attempted to be swapped.
	Funds *BigInteger `protobuf:"bytes,3,opt,name=funds,proto3" json:"funds,omitempty"`
	// The reason why the swap failed.
	FailureReason        string   `protobuf:"bytes,4,opt,name=failureReason,proto3" json:"failureReason,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SwapFailure) Reset()         { *m = SwapFailure{} }
func (m *SwapFailure) String() string { return proto.CompactTextString(m) }
func (*SwapFailure) ProtoMessage()    {}
func (*SwapFailure) Descriptor() ([]byte, []int) {
	return fileDescriptor_197ef81533ed7ae1, []int{19}
}

func (m *SwapFailure) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SwapFailure.Unmarshal(m, b)
}
func (m *SwapFailure) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SwapFailure.Marshal(b, m, deterministic)
}
func (m *SwapFailure) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SwapFailure.Merge(m, src)
}
func (m *SwapFailure) XXX_Size() int {
	return xxx_messageInfo_SwapFailure.Size(m)
}
func (m *SwapFailure) XXX_DiscardUnknown() {
	xxx_messageInfo_SwapFailure.DiscardUnknown(m)
}

var xxx_messageInfo_SwapFailure proto.InternalMessageInfo

func (m *SwapFailure) GetOrderId() string {
	if m != nil {
		return m.OrderId
	}
	return ""
}

func (m *SwapFailure) GetPairId() string {
	if m != nil {
		return m.PairId
	}
	return ""
}

func (m *SwapFailure) GetFunds() *BigInteger {
	if m != nil {
		return m.Funds
	}
	return nil
}

func (m *SwapFailure) GetFailureReason() string {
	if m != nil {
		return m.FailureReason
	}
	return ""
}

func init() {
	proto.RegisterEnum("lssdrpc.OrderSide", OrderSide_name, OrderSide_value)
	proto.RegisterEnum("lssdrpc.SwapSuccess_Role", SwapSuccess_Role_name, SwapSuccess_Role_value)
	proto.RegisterType((*BigInteger)(nil), "lssdrpc.BigInteger")
	proto.RegisterType((*AddCurrencyRequest)(nil), "lssdrpc.AddCurrencyRequest")
	proto.RegisterType((*AddCurrencyResponse)(nil), "lssdrpc.AddCurrencyResponse")
	proto.RegisterType((*EnableTradingPairRequest)(nil), "lssdrpc.EnableTradingPairRequest")
	proto.RegisterType((*EnableTradingPairResponse)(nil), "lssdrpc.EnableTradingPairResponse")
	proto.RegisterType((*ListOrdersRequest)(nil), "lssdrpc.ListOrdersRequest")
	proto.RegisterType((*ListOrdersResponse)(nil), "lssdrpc.ListOrdersResponse")
	proto.RegisterType((*PlaceOrderRequest)(nil), "lssdrpc.PlaceOrderRequest")
	proto.RegisterType((*PlaceOrderResponse)(nil), "lssdrpc.PlaceOrderResponse")
	proto.RegisterType((*OrderbookFailure)(nil), "lssdrpc.OrderbookFailure")
	proto.RegisterType((*PlaceOrderFailure)(nil), "lssdrpc.PlaceOrderFailure")
	proto.RegisterType((*CancelOrderRequest)(nil), "lssdrpc.CancelOrderRequest")
	proto.RegisterType((*CancelOrderResponse)(nil), "lssdrpc.CancelOrderResponse")
	proto.RegisterType((*SubscribeOrdersRequest)(nil), "lssdrpc.SubscribeOrdersRequest")
	proto.RegisterType((*OrderUpdate)(nil), "lssdrpc.OrderUpdate")
	proto.RegisterType((*Order)(nil), "lssdrpc.Order")
	proto.RegisterType((*SubscribeSwapsRequest)(nil), "lssdrpc.SubscribeSwapsRequest")
	proto.RegisterType((*SwapResult)(nil), "lssdrpc.SwapResult")
	proto.RegisterType((*SwapSuccess)(nil), "lssdrpc.SwapSuccess")
	proto.RegisterType((*SwapFailure)(nil), "lssdrpc.SwapFailure")
}

func init() { proto.RegisterFile("lssdrpc.proto", fileDescriptor_197ef81533ed7ae1) }

var fileDescriptor_197ef81533ed7ae1 = []byte{
	// 1050 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xb4, 0x57, 0x4f, 0x6f, 0xdc, 0x44,
	0x14, 0xaf, 0xb3, 0xff, 0x9f, 0x93, 0x65, 0x3b, 0x49, 0x8b, 0xbb, 0x89, 0x42, 0x19, 0xa1, 0xaa,
	0x54, 0x22, 0x8a, 0xb6, 0x80, 0x90, 0xe0, 0x92, 0x44, 0x09, 0x29, 0x7f, 0xd4, 0x95, 0xb7, 0x70,
	0xe0, 0xe6, 0xb5, 0x27, 0x89, 0xa9, 0xd7, 0x5e, 0x66, 0xec, 0x46, 0x39, 0xf2, 0x0d, 0xb8, 0xf0,
	0x01, 0x38, 0x22, 0x71, 0xe2, 0xc6, 0x37, 0xe1, 0x8b, 0x70, 0x67, 0xfe, 0xd9, 0x1e, 0xc7, 0xde,
	0x6c, 0x39, 0x70, 0xf3, 0x7b, 0xef, 0x37, 0x6f, 0xde, 0xff, 0x37, 0x86, 0xad, 0x88, 0xb1, 0x80,
	0x2e, 0xfd, 0x83, 0x25, 0x4d, 0xd2, 0x04, 0xf5, 0x34, 0x89, 0x31, 0xc0, 0x71, 0x78, 0xf9, 0x22,
	0x4e, 0xc9, 0x25, 0xa1, 0x68, 0x07, 0x3a, 0x6f, 0xbc, 0x28, 0x23, 0x8e, 0xf5, 0xd8, 0x7a, 0x3a,
	0x70, 0x15, 0x81, 0x7f, 0xb5, 0x00, 0x1d, 0x05, 0xc1, 0x49, 0x46, 0x29, 0x89, 0xfd, 0x1b, 0x97,
	0xfc, 0x94, 0x11, 0x96, 0xa2, 0x31, 0xf4, 0x7d, 0xcd, 0xd2, 0xf8, 0x82, 0x46, 0xfb, 0x00, 0x51,
	0x1c, 0x9c, 0x5c, 0x79, 0x71, 0x4c, 0x22, 0x67, 0x43, 0x4a, 0x0d, 0x0e, 0xda, 0xe3, 0x67, 0x09,
	0x4d, 0xa7, 0x5e, 0x7a, 0xe5, 0xb4, 0x84, 0xf4, 0xfc, 0x9e, 0x5b, 0x70, 0xb8, 0xe6, 0x1e, 0xf5,
	0xae, 0x4f, 0x38, 0xe9, 0xb4, 0xb5, 0x30, 0x67, 0x1c, 0x0f, 0xa0, 0x97, 0x46, 0x4c, 0x7c, 0xe2,
	0x07, 0xb0, 0x5d, 0x31, 0x8b, 0x2d, 0x93, 0x98, 0x11, 0x3c, 0x01, 0xe7, 0x34, 0xf6, 0xe6, 0x11,
	0x79, 0x45, 0xbd, 0x20, 0x8c, 0x2f, 0xa7, 0x5e, 0x48, 0x73, 0x9b, 0x1f, 0x42, 0x77, 0xc9, 0xc9,
	0x17, 0x81, 0xb6, 0x58, 0x53, 0x78, 0x17, 0x1e, 0x35, 0x9c, 0xd1, 0x0a, 0x7f, 0xb6, 0xe0, 0xfe,
	0x37, 0x21, 0x4b, 0x5f, 0xd2, 0x80, 0x50, 0xb6, 0x46, 0x15, 0x7a, 0x06, 0xa3, 0x30, 0xf6, 0xa3,
	0x2c, 0x20, 0x2f, 0xaf, 0x63, 0x75, 0x44, 0x06, 0xa0, 0xef, 0xd6, 0xf8, 0x08, 0x41, 0x9b, 0xbd,
	0x0e, 0x97, 0x32, 0x04, 0x5b, 0xae, 0xfc, 0x16, 0x39, 0x88, 0xc2, 0x45, 0xa8, 0x5c, 0xdf, 0x72,
	0x15, 0x81, 0xbf, 0x00, 0x64, 0x9a, 0xa0, 0x2c, 0x43, 0x4f, 0xa0, 0x9b, 0xa8, 0x1b, 0xac, 0xc7,
	0xad, 0xa7, 0xf6, 0x64, 0x78, 0x90, 0xa7, 0x59, 0x02, 0x5d, 0x2d, 0xc5, 0xbf, 0x73, 0x0f, 0xa6,
	0x91, 0xe7, 0x13, 0xc5, 0x5e, 0xe3, 0xc1, 0x13, 0x6e, 0x55, 0x18, 0x10, 0x69, 0xf5, 0x70, 0x82,
	0xaa, 0x3a, 0x67, 0x5c, 0xe2, 0x4a, 0x39, 0xfa, 0x10, 0x3a, 0x17, 0x59, 0x1c, 0x30, 0x69, 0xbe,
	0x3d, 0xd9, 0x2e, 0x80, 0x65, 0x45, 0xb9, 0x0a, 0x21, 0xa0, 0x4b, 0x1a, 0xfa, 0x44, 0x3a, 0xb5,
	0x0a, 0x2a, 0x11, 0xf8, 0x2f, 0x5e, 0x6d, 0xa6, 0xad, 0xda, 0xd5, 0xcf, 0xc0, 0x66, 0xd7, 0xde,
	0x72, 0x96, 0xf9, 0x3e, 0x61, 0x4c, 0x5a, 0x6c, 0x4f, 0x76, 0x0a, 0x3d, 0xb3, 0x52, 0xc6, 0xab,
	0xc5, 0x84, 0x72, 0x77, 0x3a, 0x32, 0x0c, 0xd2, 0x9f, 0x5a, 0x8c, 0x38, 0x5a, 0x89, 0xd1, 0xa7,
	0xd0, 0xbb, 0xf0, 0xc2, 0x28, 0xa3, 0x44, 0x3b, 0x34, 0x2e, 0x90, 0xa5, 0x3d, 0x67, 0x0a, 0x21,
	0x2a, 0x52, 0x83, 0x45, 0x45, 0x26, 0x59, 0xea, 0x27, 0x0b, 0x82, 0xff, 0xb4, 0x60, 0x24, 0x61,
	0xf3, 0x24, 0x79, 0xad, 0xa1, 0x2b, 0xc3, 0x5c, 0x84, 0x6f, 0x63, 0x6d, 0xf8, 0x3e, 0x80, 0x2d,
	0x7d, 0x9b, 0x4b, 0x3c, 0x96, 0xc4, 0xaa, 0x67, 0xdc, 0x2a, 0x13, 0x7d, 0x02, 0x36, 0xe5, 0xa9,
	0x0d, 0x29, 0x09, 0xce, 0xc8, 0x9d, 0xa1, 0x36, 0x71, 0xf8, 0xb7, 0x4a, 0x71, 0xe4, 0x56, 0xeb,
	0x78, 0x6b, 0xb2, 0x31, 0xde, 0x65, 0x2c, 0x4c, 0x28, 0xfa, 0x12, 0x46, 0xc9, 0xad, 0x18, 0x68,
	0x17, 0x1f, 0x55, 0x43, 0x6f, 0x00, 0xb8, 0x8e, 0xda, 0x21, 0x11, 0x58, 0xed, 0x20, 0x3e, 0x03,
	0x74, 0xe2, 0xc5, 0x3e, 0x89, 0xde, 0xaa, 0x80, 0x1d, 0x9e, 0x11, 0x81, 0xe3, 0x02, 0x35, 0x7a,
	0x72, 0x52, 0x8c, 0x8c, 0x8a, 0x1e, 0xdd, 0xe1, 0x0e, 0x3c, 0x9c, 0x65, 0x73, 0xe6, 0xd3, 0x70,
	0x4e, 0x2a, 0x5d, 0x8e, 0x33, 0xb0, 0x25, 0xe3, 0xbb, 0x65, 0xe0, 0xa5, 0xa4, 0xac, 0x25, 0xeb,
	0xee, 0x5a, 0xfa, 0x18, 0x36, 0x13, 0x75, 0xc3, 0x22, 0xe1, 0x43, 0x74, 0x65, 0xe9, 0x55, 0x50,
	0xc7, 0x7d, 0xe8, 0x66, 0xf2, 0x1e, 0xfc, 0x8f, 0x05, 0x1d, 0x89, 0xf9, 0xef, 0x3e, 0x96, 0xbd,
	0xd6, 0x5a, 0xd7, 0x6b, 0x65, 0x09, 0xb6, 0xd7, 0x96, 0xe0, 0x1e, 0x0c, 0x7c, 0x4a, 0xb8, 0x6d,
	0xc1, 0x51, 0xea, 0x74, 0x38, 0xbc, 0xed, 0x96, 0x8c, 0x62, 0x64, 0x74, 0xd7, 0x8c, 0x0c, 0xbe,
	0x17, 0x42, 0x96, 0xcf, 0x3f, 0xa7, 0x27, 0xc7, 0xa2, 0xc1, 0xc1, 0xef, 0xc2, 0x83, 0x22, 0x11,
	0xa2, 0xc4, 0x8a, 0x3c, 0xdc, 0x00, 0x08, 0x9a, 0x67, 0x2c, 0x8b, 0x52, 0x74, 0x08, 0x3d, 0xf6,
	0x56, 0x83, 0x20, 0x87, 0x89, 0x13, 0x17, 0x95, 0x5a, 0x5c, 0x55, 0xca, 0x45, 0x5b, 0xf7, 0xf4,
	0x2e, 0xc4, 0x7f, 0xb7, 0xc0, 0x36, 0xb4, 0x9a, 0x91, 0xb7, 0xaa, 0x91, 0x2f, 0x73, 0xb5, 0xd1,
	0xdc, 0xe9, 0xeb, 0x07, 0x25, 0x9f, 0xfe, 0xf4, 0xdc, 0x63, 0x57, 0x6a, 0xf1, 0xb9, 0x8a, 0x40,
	0x9f, 0xc3, 0xd0, 0x5b, 0x24, 0x59, 0x9c, 0xba, 0xc4, 0x27, 0xe1, 0x1b, 0x12, 0xc8, 0x0c, 0xac,
	0xd0, 0x74, 0x0b, 0x8a, 0x9e, 0x03, 0x28, 0xce, 0x8c, 0xc4, 0xa9, 0xcc, 0xd0, 0x8a, 0x83, 0x06,
	0x0c, 0x7d, 0x04, 0x6d, 0x9a, 0x44, 0x44, 0xa6, 0x68, 0x68, 0x34, 0xae, 0x11, 0x88, 0x03, 0x97,
	0x03, 0x5c, 0x09, 0x13, 0x4b, 0xcf, 0x2f, 0xf6, 0xb0, 0x36, 0xb1, 0x2f, 0x3d, 0xa8, 0xf1, 0x11,
	0x86, 0xcd, 0x9c, 0x27, 0x2d, 0x1a, 0x48, 0x5c, 0x85, 0x27, 0xaa, 0x8d, 0x4e, 0x29, 0x09, 0x17,
	0xde, 0x25, 0x71, 0x40, 0x02, 0x4a, 0x46, 0x59, 0xe1, 0xf6, 0xda, 0x6d, 0xb2, 0x07, 0x6d, 0x61,
	0x26, 0x1a, 0x40, 0xe7, 0xd5, 0xd1, 0xd7, 0xa7, 0xee, 0xe8, 0x9e, 0xf8, 0xfc, 0x56, 0x7e, 0x5a,
	0xf8, 0x17, 0x4b, 0xa5, 0x36, 0x1f, 0x5d, 0xff, 0x6b, 0x6a, 0x6b, 0x43, 0xbc, 0xdd, 0x30, 0xc4,
	0x9f, 0xed, 0xc3, 0xa0, 0x68, 0x1a, 0xd4, 0x83, 0xd6, 0x3c, 0xbb, 0xe1, 0x36, 0xf7, 0x79, 0x7f,
	0x91, 0x28, 0x1a, 0x59, 0x93, 0xef, 0x01, 0x74, 0xa4, 0x42, 0xc2, 0xd0, 0x39, 0xd8, 0xc6, 0x13,
	0x08, 0xed, 0x16, 0xd7, 0xd7, 0xdf, 0x6b, 0xe3, 0xbd, 0x66, 0xa1, 0x1a, 0x81, 0x93, 0x1f, 0x61,
	0x33, 0x2d, 0xdf, 0x3e, 0x0c, 0xfd, 0x00, 0xf7, 0x6b, 0x2f, 0x22, 0xf4, 0x7e, 0xa1, 0x62, 0xd5,
	0x0b, 0x6b, 0x8c, 0xef, 0x82, 0xe8, 0xbb, 0xfe, 0xd8, 0xc8, 0xdf, 0x2d, 0xe8, 0x14, 0xa0, 0xdc,
	0x3d, 0xa8, 0x69, 0xe3, 0xe6, 0x8a, 0x77, 0x1b, 0x65, 0xfa, 0x75, 0xc0, 0xe3, 0x60, 0xcc, 0x75,
	0x23, 0x0e, 0xf5, 0xad, 0x61, 0xc4, 0xa1, 0x61, 0x15, 0xa0, 0xaf, 0xe0, 0x9d, 0x5b, 0xab, 0x00,
	0xbd, 0x57, 0x56, 0x7f, 0xe3, 0x92, 0x18, 0xef, 0x54, 0xe7, 0x9d, 0xda, 0x15, 0x87, 0x96, 0x70,
	0xae, 0x7c, 0xb4, 0x19, 0xce, 0xd5, 0x1e, 0x93, 0x86, 0x73, 0xf5, 0x57, 0xde, 0x64, 0x0a, 0x1d,
	0xb1, 0x5f, 0x19, 0xdf, 0xac, 0xc3, 0xea, 0x74, 0x44, 0xfb, 0x75, 0xd3, 0xcc, 0xb1, 0x39, 0xde,
	0xae, 0x34, 0xae, 0x9a, 0x9e, 0x87, 0xd6, 0xbc, 0x2b, 0xff, 0x02, 0x9e, 0xff, 0x1b, 0x00, 0x00,
	0xff, 0xff, 0xfa, 0xb4, 0x4d, 0x9c, 0x16, 0x0c, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// CurrenciesClient is the client API for Currencies service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type CurrenciesClient interface {
	// before being able to enable a trading pair, you need to add the two involved currencies
	// for example, for activating XSN_LTC, you will add the XSN currency, and the LTC currency.
	//
	// For now, only currencies supported by lnd (lightning network) work.
	AddCurrency(ctx context.Context, in *AddCurrencyRequest, opts ...grpc.CallOption) (*AddCurrencyResponse, error)
}

type currenciesClient struct {
	cc *grpc.ClientConn
}

func NewCurrenciesClient(cc *grpc.ClientConn) CurrenciesClient {
	return &currenciesClient{cc}
}

func (c *currenciesClient) AddCurrency(ctx context.Context, in *AddCurrencyRequest, opts ...grpc.CallOption) (*AddCurrencyResponse, error) {
	out := new(AddCurrencyResponse)
	err := c.cc.Invoke(ctx, "/lssdrpc.currencies/AddCurrency", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CurrenciesServer is the server API for Currencies service.
type CurrenciesServer interface {
	// before being able to enable a trading pair, you need to add the two involved currencies
	// for example, for activating XSN_LTC, you will add the XSN currency, and the LTC currency.
	//
	// For now, only currencies supported by lnd (lightning network) work.
	AddCurrency(context.Context, *AddCurrencyRequest) (*AddCurrencyResponse, error)
}

// UnimplementedCurrenciesServer can be embedded to have forward compatible implementations.
type UnimplementedCurrenciesServer struct {
}

func (*UnimplementedCurrenciesServer) AddCurrency(ctx context.Context, req *AddCurrencyRequest) (*AddCurrencyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddCurrency not implemented")
}

func RegisterCurrenciesServer(s *grpc.Server, srv CurrenciesServer) {
	s.RegisterService(&_Currencies_serviceDesc, srv)
}

func _Currencies_AddCurrency_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddCurrencyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CurrenciesServer).AddCurrency(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lssdrpc.currencies/AddCurrency",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CurrenciesServer).AddCurrency(ctx, req.(*AddCurrencyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Currencies_serviceDesc = grpc.ServiceDesc{
	ServiceName: "lssdrpc.currencies",
	HandlerType: (*CurrenciesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddCurrency",
			Handler:    _Currencies_AddCurrency_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "lssdrpc.proto",
}

// TradingPairsClient is the client API for TradingPairs service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type TradingPairsClient interface {
	// Enables the given trading pair, like XSN_LTC, before calling this method, you must
	// have already added the involved currencies.
	//
	// After enabling a trading pair, lssd will download the existing orders form the orderbook,
	// try waiting some seconds (5 should be enough) before performing any other operation, so
	// that lssd has the time to sync because this is done in the background.
	EnableTradingPair(ctx context.Context, in *EnableTradingPairRequest, opts ...grpc.CallOption) (*EnableTradingPairResponse, error)
}

type tradingPairsClient struct {
	cc *grpc.ClientConn
}

func NewTradingPairsClient(cc *grpc.ClientConn) TradingPairsClient {
	return &tradingPairsClient{cc}
}

func (c *tradingPairsClient) EnableTradingPair(ctx context.Context, in *EnableTradingPairRequest, opts ...grpc.CallOption) (*EnableTradingPairResponse, error) {
	out := new(EnableTradingPairResponse)
	err := c.cc.Invoke(ctx, "/lssdrpc.tradingPairs/EnableTradingPair", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TradingPairsServer is the server API for TradingPairs service.
type TradingPairsServer interface {
	// Enables the given trading pair, like XSN_LTC, before calling this method, you must
	// have already added the involved currencies.
	//
	// After enabling a trading pair, lssd will download the existing orders form the orderbook,
	// try waiting some seconds (5 should be enough) before performing any other operation, so
	// that lssd has the time to sync because this is done in the background.
	EnableTradingPair(context.Context, *EnableTradingPairRequest) (*EnableTradingPairResponse, error)
}

// UnimplementedTradingPairsServer can be embedded to have forward compatible implementations.
type UnimplementedTradingPairsServer struct {
}

func (*UnimplementedTradingPairsServer) EnableTradingPair(ctx context.Context, req *EnableTradingPairRequest) (*EnableTradingPairResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EnableTradingPair not implemented")
}

func RegisterTradingPairsServer(s *grpc.Server, srv TradingPairsServer) {
	s.RegisterService(&_TradingPairs_serviceDesc, srv)
}

func _TradingPairs_EnableTradingPair_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EnableTradingPairRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradingPairsServer).EnableTradingPair(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lssdrpc.tradingPairs/EnableTradingPair",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradingPairsServer).EnableTradingPair(ctx, req.(*EnableTradingPairRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _TradingPairs_serviceDesc = grpc.ServiceDesc{
	ServiceName: "lssdrpc.tradingPairs",
	HandlerType: (*TradingPairsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "EnableTradingPair",
			Handler:    _TradingPairs_EnableTradingPair_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "lssdrpc.proto",
}

// OrdersClient is the client API for Orders service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type OrdersClient interface {
	// Places an order to the orderbook, you must have already enabled the involved trading pair.
	//
	// NOTE: After the order is matched, lssd will perform the swap automatically, so, your lnd
	// needs to have a channel with enough coins to our hub.
	PlaceOrder(ctx context.Context, in *PlaceOrderRequest, opts ...grpc.CallOption) (*PlaceOrderResponse, error)
	// Cancels an existing order.
	CancelOrder(ctx context.Context, in *CancelOrderRequest, opts ...grpc.CallOption) (*CancelOrderResponse, error)
	// Susbcribe to events related to the orders in the orderbook.
	SubscribeOrders(ctx context.Context, in *SubscribeOrdersRequest, opts ...grpc.CallOption) (Orders_SubscribeOrdersClient, error)
	// List the available order on the orderbook.
	ListOrders(ctx context.Context, in *ListOrdersRequest, opts ...grpc.CallOption) (*ListOrdersResponse, error)
}

type ordersClient struct {
	cc *grpc.ClientConn
}

func NewOrdersClient(cc *grpc.ClientConn) OrdersClient {
	return &ordersClient{cc}
}

func (c *ordersClient) PlaceOrder(ctx context.Context, in *PlaceOrderRequest, opts ...grpc.CallOption) (*PlaceOrderResponse, error) {
	out := new(PlaceOrderResponse)
	err := c.cc.Invoke(ctx, "/lssdrpc.orders/PlaceOrder", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ordersClient) CancelOrder(ctx context.Context, in *CancelOrderRequest, opts ...grpc.CallOption) (*CancelOrderResponse, error) {
	out := new(CancelOrderResponse)
	err := c.cc.Invoke(ctx, "/lssdrpc.orders/CancelOrder", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ordersClient) SubscribeOrders(ctx context.Context, in *SubscribeOrdersRequest, opts ...grpc.CallOption) (Orders_SubscribeOrdersClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Orders_serviceDesc.Streams[0], "/lssdrpc.orders/SubscribeOrders", opts...)
	if err != nil {
		return nil, err
	}
	x := &ordersSubscribeOrdersClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Orders_SubscribeOrdersClient interface {
	Recv() (*OrderUpdate, error)
	grpc.ClientStream
}

type ordersSubscribeOrdersClient struct {
	grpc.ClientStream
}

func (x *ordersSubscribeOrdersClient) Recv() (*OrderUpdate, error) {
	m := new(OrderUpdate)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *ordersClient) ListOrders(ctx context.Context, in *ListOrdersRequest, opts ...grpc.CallOption) (*ListOrdersResponse, error) {
	out := new(ListOrdersResponse)
	err := c.cc.Invoke(ctx, "/lssdrpc.orders/ListOrders", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// OrdersServer is the server API for Orders service.
type OrdersServer interface {
	// Places an order to the orderbook, you must have already enabled the involved trading pair.
	//
	// NOTE: After the order is matched, lssd will perform the swap automatically, so, your lnd
	// needs to have a channel with enough coins to our hub.
	PlaceOrder(context.Context, *PlaceOrderRequest) (*PlaceOrderResponse, error)
	// Cancels an existing order.
	CancelOrder(context.Context, *CancelOrderRequest) (*CancelOrderResponse, error)
	// Susbcribe to events related to the orders in the orderbook.
	SubscribeOrders(*SubscribeOrdersRequest, Orders_SubscribeOrdersServer) error
	// List the available order on the orderbook.
	ListOrders(context.Context, *ListOrdersRequest) (*ListOrdersResponse, error)
}

// UnimplementedOrdersServer can be embedded to have forward compatible implementations.
type UnimplementedOrdersServer struct {
}

func (*UnimplementedOrdersServer) PlaceOrder(ctx context.Context, req *PlaceOrderRequest) (*PlaceOrderResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PlaceOrder not implemented")
}
func (*UnimplementedOrdersServer) CancelOrder(ctx context.Context, req *CancelOrderRequest) (*CancelOrderResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CancelOrder not implemented")
}
func (*UnimplementedOrdersServer) SubscribeOrders(req *SubscribeOrdersRequest, srv Orders_SubscribeOrdersServer) error {
	return status.Errorf(codes.Unimplemented, "method SubscribeOrders not implemented")
}
func (*UnimplementedOrdersServer) ListOrders(ctx context.Context, req *ListOrdersRequest) (*ListOrdersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListOrders not implemented")
}

func RegisterOrdersServer(s *grpc.Server, srv OrdersServer) {
	s.RegisterService(&_Orders_serviceDesc, srv)
}

func _Orders_PlaceOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PlaceOrderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrdersServer).PlaceOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lssdrpc.orders/PlaceOrder",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrdersServer).PlaceOrder(ctx, req.(*PlaceOrderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Orders_CancelOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CancelOrderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrdersServer).CancelOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lssdrpc.orders/CancelOrder",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrdersServer).CancelOrder(ctx, req.(*CancelOrderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Orders_SubscribeOrders_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscribeOrdersRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(OrdersServer).SubscribeOrders(m, &ordersSubscribeOrdersServer{stream})
}

type Orders_SubscribeOrdersServer interface {
	Send(*OrderUpdate) error
	grpc.ServerStream
}

type ordersSubscribeOrdersServer struct {
	grpc.ServerStream
}

func (x *ordersSubscribeOrdersServer) Send(m *OrderUpdate) error {
	return x.ServerStream.SendMsg(m)
}

func _Orders_ListOrders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListOrdersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrdersServer).ListOrders(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lssdrpc.orders/ListOrders",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrdersServer).ListOrders(ctx, req.(*ListOrdersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Orders_serviceDesc = grpc.ServiceDesc{
	ServiceName: "lssdrpc.orders",
	HandlerType: (*OrdersServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "PlaceOrder",
			Handler:    _Orders_PlaceOrder_Handler,
		},
		{
			MethodName: "CancelOrder",
			Handler:    _Orders_CancelOrder_Handler,
		},
		{
			MethodName: "ListOrders",
			Handler:    _Orders_ListOrders_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SubscribeOrders",
			Handler:       _Orders_SubscribeOrders_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "lssdrpc.proto",
}

// SwapsClient is the client API for Swaps service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type SwapsClient interface {
	SubscribeSwaps(ctx context.Context, in *SubscribeSwapsRequest, opts ...grpc.CallOption) (Swaps_SubscribeSwapsClient, error)
}

type swapsClient struct {
	cc *grpc.ClientConn
}

func NewSwapsClient(cc *grpc.ClientConn) SwapsClient {
	return &swapsClient{cc}
}

func (c *swapsClient) SubscribeSwaps(ctx context.Context, in *SubscribeSwapsRequest, opts ...grpc.CallOption) (Swaps_SubscribeSwapsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Swaps_serviceDesc.Streams[0], "/lssdrpc.swaps/SubscribeSwaps", opts...)
	if err != nil {
		return nil, err
	}
	x := &swapsSubscribeSwapsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Swaps_SubscribeSwapsClient interface {
	Recv() (*SwapResult, error)
	grpc.ClientStream
}

type swapsSubscribeSwapsClient struct {
	grpc.ClientStream
}

func (x *swapsSubscribeSwapsClient) Recv() (*SwapResult, error) {
	m := new(SwapResult)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// SwapsServer is the server API for Swaps service.
type SwapsServer interface {
	SubscribeSwaps(*SubscribeSwapsRequest, Swaps_SubscribeSwapsServer) error
}

// UnimplementedSwapsServer can be embedded to have forward compatible implementations.
type UnimplementedSwapsServer struct {
}

func (*UnimplementedSwapsServer) SubscribeSwaps(req *SubscribeSwapsRequest, srv Swaps_SubscribeSwapsServer) error {
	return status.Errorf(codes.Unimplemented, "method SubscribeSwaps not implemented")
}

func RegisterSwapsServer(s *grpc.Server, srv SwapsServer) {
	s.RegisterService(&_Swaps_serviceDesc, srv)
}

func _Swaps_SubscribeSwaps_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscribeSwapsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(SwapsServer).SubscribeSwaps(m, &swapsSubscribeSwapsServer{stream})
}

type Swaps_SubscribeSwapsServer interface {
	Send(*SwapResult) error
	grpc.ServerStream
}

type swapsSubscribeSwapsServer struct {
	grpc.ServerStream
}

func (x *swapsSubscribeSwapsServer) Send(m *SwapResult) error {
	return x.ServerStream.SendMsg(m)
}

var _Swaps_serviceDesc = grpc.ServiceDesc{
	ServiceName: "lssdrpc.swaps",
	HandlerType: (*SwapsServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SubscribeSwaps",
			Handler:       _Swaps_SubscribeSwaps_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "lssdrpc.proto",
}
