// Code generated by protoc-gen-go. DO NOT EDIT.
// source: lssdrpc.proto

package lssdrpc

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type OrderSide int32

const (
	OrderSide_buy  OrderSide = 0
	OrderSide_sell OrderSide = 1
)

var OrderSide_name = map[int32]string{
	0: "buy",
	1: "sell",
}

var OrderSide_value = map[string]int32{
	"buy":  0,
	"sell": 1,
}

func (x OrderSide) String() string {
	return proto.EnumName(OrderSide_name, int32(x))
}

func (OrderSide) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_197ef81533ed7ae1, []int{0}
}

type SwapSuccess_Role int32

const (
	SwapSuccess_TAKER SwapSuccess_Role = 0
	SwapSuccess_MAKER SwapSuccess_Role = 1
)

var SwapSuccess_Role_name = map[int32]string{
	0: "TAKER",
	1: "MAKER",
}

var SwapSuccess_Role_value = map[string]int32{
	"TAKER": 0,
	"MAKER": 1,
}

func (x SwapSuccess_Role) String() string {
	return proto.EnumName(SwapSuccess_Role_name, int32(x))
}

func (SwapSuccess_Role) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_197ef81533ed7ae1, []int{24, 0}
}

// A non-negative Big Integer represented as string, like "100000000"
type BigInteger struct {
	Value                string   `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BigInteger) Reset()         { *m = BigInteger{} }
func (m *BigInteger) String() string { return proto.CompactTextString(m) }
func (*BigInteger) ProtoMessage()    {}
func (*BigInteger) Descriptor() ([]byte, []int) {
	return fileDescriptor_197ef81533ed7ae1, []int{0}
}

func (m *BigInteger) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BigInteger.Unmarshal(m, b)
}
func (m *BigInteger) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BigInteger.Marshal(b, m, deterministic)
}
func (m *BigInteger) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BigInteger.Merge(m, src)
}
func (m *BigInteger) XXX_Size() int {
	return xxx_messageInfo_BigInteger.Size(m)
}
func (m *BigInteger) XXX_DiscardUnknown() {
	xxx_messageInfo_BigInteger.DiscardUnknown(m)
}

var xxx_messageInfo_BigInteger proto.InternalMessageInfo

func (m *BigInteger) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

type AddCurrencyRequest struct {
	// the currency, like XSN or LTC
	Currency string `protobuf:"bytes,1,opt,name=currency,proto3" json:"currency,omitempty"`
	// the address:port allowing lssd to connect to this currency lnd, like "localhost:10001"
	// right now, it is assumed that the bot runs on the same network than lssd, so, there is
	// no support for authentication.
	LndChannel string `protobuf:"bytes,2,opt,name=lndChannel,proto3" json:"lndChannel,omitempty"`
	// the tls certificate used by lnd, so that lssd can be sure it's connecting to the right lnd
	//
	// Types that are valid to be assigned to TlsCert:
	//	*AddCurrencyRequest_CertPath
	//	*AddCurrencyRequest_RawCert
	TlsCert              isAddCurrencyRequest_TlsCert `protobuf_oneof:"tlsCert"`
	XXX_NoUnkeyedLiteral struct{}                     `json:"-"`
	XXX_unrecognized     []byte                       `json:"-"`
	XXX_sizecache        int32                        `json:"-"`
}

func (m *AddCurrencyRequest) Reset()         { *m = AddCurrencyRequest{} }
func (m *AddCurrencyRequest) String() string { return proto.CompactTextString(m) }
func (*AddCurrencyRequest) ProtoMessage()    {}
func (*AddCurrencyRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_197ef81533ed7ae1, []int{1}
}

func (m *AddCurrencyRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AddCurrencyRequest.Unmarshal(m, b)
}
func (m *AddCurrencyRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AddCurrencyRequest.Marshal(b, m, deterministic)
}
func (m *AddCurrencyRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddCurrencyRequest.Merge(m, src)
}
func (m *AddCurrencyRequest) XXX_Size() int {
	return xxx_messageInfo_AddCurrencyRequest.Size(m)
}
func (m *AddCurrencyRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AddCurrencyRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AddCurrencyRequest proto.InternalMessageInfo

func (m *AddCurrencyRequest) GetCurrency() string {
	if m != nil {
		return m.Currency
	}
	return ""
}

func (m *AddCurrencyRequest) GetLndChannel() string {
	if m != nil {
		return m.LndChannel
	}
	return ""
}

type isAddCurrencyRequest_TlsCert interface {
	isAddCurrencyRequest_TlsCert()
}

type AddCurrencyRequest_CertPath struct {
	CertPath string `protobuf:"bytes,3,opt,name=certPath,proto3,oneof"`
}

type AddCurrencyRequest_RawCert struct {
	RawCert string `protobuf:"bytes,4,opt,name=rawCert,proto3,oneof"`
}

func (*AddCurrencyRequest_CertPath) isAddCurrencyRequest_TlsCert() {}

func (*AddCurrencyRequest_RawCert) isAddCurrencyRequest_TlsCert() {}

func (m *AddCurrencyRequest) GetTlsCert() isAddCurrencyRequest_TlsCert {
	if m != nil {
		return m.TlsCert
	}
	return nil
}

func (m *AddCurrencyRequest) GetCertPath() string {
	if x, ok := m.GetTlsCert().(*AddCurrencyRequest_CertPath); ok {
		return x.CertPath
	}
	return ""
}

func (m *AddCurrencyRequest) GetRawCert() string {
	if x, ok := m.GetTlsCert().(*AddCurrencyRequest_RawCert); ok {
		return x.RawCert
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*AddCurrencyRequest) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*AddCurrencyRequest_CertPath)(nil),
		(*AddCurrencyRequest_RawCert)(nil),
	}
}

type AddCurrencyResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AddCurrencyResponse) Reset()         { *m = AddCurrencyResponse{} }
func (m *AddCurrencyResponse) String() string { return proto.CompactTextString(m) }
func (*AddCurrencyResponse) ProtoMessage()    {}
func (*AddCurrencyResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_197ef81533ed7ae1, []int{2}
}

func (m *AddCurrencyResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AddCurrencyResponse.Unmarshal(m, b)
}
func (m *AddCurrencyResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AddCurrencyResponse.Marshal(b, m, deterministic)
}
func (m *AddCurrencyResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddCurrencyResponse.Merge(m, src)
}
func (m *AddCurrencyResponse) XXX_Size() int {
	return xxx_messageInfo_AddCurrencyResponse.Size(m)
}
func (m *AddCurrencyResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AddCurrencyResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AddCurrencyResponse proto.InternalMessageInfo

type GetAddedCurrenciesRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetAddedCurrenciesRequest) Reset()         { *m = GetAddedCurrenciesRequest{} }
func (m *GetAddedCurrenciesRequest) String() string { return proto.CompactTextString(m) }
func (*GetAddedCurrenciesRequest) ProtoMessage()    {}
func (*GetAddedCurrenciesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_197ef81533ed7ae1, []int{3}
}

func (m *GetAddedCurrenciesRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetAddedCurrenciesRequest.Unmarshal(m, b)
}
func (m *GetAddedCurrenciesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetAddedCurrenciesRequest.Marshal(b, m, deterministic)
}
func (m *GetAddedCurrenciesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetAddedCurrenciesRequest.Merge(m, src)
}
func (m *GetAddedCurrenciesRequest) XXX_Size() int {
	return xxx_messageInfo_GetAddedCurrenciesRequest.Size(m)
}
func (m *GetAddedCurrenciesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetAddedCurrenciesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetAddedCurrenciesRequest proto.InternalMessageInfo

type GetAddedCurrenciesResponse struct {
	Currency             []string `protobuf:"bytes,1,rep,name=currency,proto3" json:"currency,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetAddedCurrenciesResponse) Reset()         { *m = GetAddedCurrenciesResponse{} }
func (m *GetAddedCurrenciesResponse) String() string { return proto.CompactTextString(m) }
func (*GetAddedCurrenciesResponse) ProtoMessage()    {}
func (*GetAddedCurrenciesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_197ef81533ed7ae1, []int{4}
}

func (m *GetAddedCurrenciesResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetAddedCurrenciesResponse.Unmarshal(m, b)
}
func (m *GetAddedCurrenciesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetAddedCurrenciesResponse.Marshal(b, m, deterministic)
}
func (m *GetAddedCurrenciesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetAddedCurrenciesResponse.Merge(m, src)
}
func (m *GetAddedCurrenciesResponse) XXX_Size() int {
	return xxx_messageInfo_GetAddedCurrenciesResponse.Size(m)
}
func (m *GetAddedCurrenciesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetAddedCurrenciesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetAddedCurrenciesResponse proto.InternalMessageInfo

func (m *GetAddedCurrenciesResponse) GetCurrency() []string {
	if m != nil {
		return m.Currency
	}
	return nil
}

type EnableTradingPairRequest struct {
	PairId               string   `protobuf:"bytes,1,opt,name=pairId,proto3" json:"pairId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EnableTradingPairRequest) Reset()         { *m = EnableTradingPairRequest{} }
func (m *EnableTradingPairRequest) String() string { return proto.CompactTextString(m) }
func (*EnableTradingPairRequest) ProtoMessage()    {}
func (*EnableTradingPairRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_197ef81533ed7ae1, []int{5}
}

func (m *EnableTradingPairRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_EnableTradingPairRequest.Unmarshal(m, b)
}
func (m *EnableTradingPairRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_EnableTradingPairRequest.Marshal(b, m, deterministic)
}
func (m *EnableTradingPairRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EnableTradingPairRequest.Merge(m, src)
}
func (m *EnableTradingPairRequest) XXX_Size() int {
	return xxx_messageInfo_EnableTradingPairRequest.Size(m)
}
func (m *EnableTradingPairRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_EnableTradingPairRequest.DiscardUnknown(m)
}

var xxx_messageInfo_EnableTradingPairRequest proto.InternalMessageInfo

func (m *EnableTradingPairRequest) GetPairId() string {
	if m != nil {
		return m.PairId
	}
	return ""
}

type EnableTradingPairResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EnableTradingPairResponse) Reset()         { *m = EnableTradingPairResponse{} }
func (m *EnableTradingPairResponse) String() string { return proto.CompactTextString(m) }
func (*EnableTradingPairResponse) ProtoMessage()    {}
func (*EnableTradingPairResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_197ef81533ed7ae1, []int{6}
}

func (m *EnableTradingPairResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_EnableTradingPairResponse.Unmarshal(m, b)
}
func (m *EnableTradingPairResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_EnableTradingPairResponse.Marshal(b, m, deterministic)
}
func (m *EnableTradingPairResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EnableTradingPairResponse.Merge(m, src)
}
func (m *EnableTradingPairResponse) XXX_Size() int {
	return xxx_messageInfo_EnableTradingPairResponse.Size(m)
}
func (m *EnableTradingPairResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_EnableTradingPairResponse.DiscardUnknown(m)
}

var xxx_messageInfo_EnableTradingPairResponse proto.InternalMessageInfo

type GetActiveTradingPairRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetActiveTradingPairRequest) Reset()         { *m = GetActiveTradingPairRequest{} }
func (m *GetActiveTradingPairRequest) String() string { return proto.CompactTextString(m) }
func (*GetActiveTradingPairRequest) ProtoMessage()    {}
func (*GetActiveTradingPairRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_197ef81533ed7ae1, []int{7}
}

func (m *GetActiveTradingPairRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetActiveTradingPairRequest.Unmarshal(m, b)
}
func (m *GetActiveTradingPairRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetActiveTradingPairRequest.Marshal(b, m, deterministic)
}
func (m *GetActiveTradingPairRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetActiveTradingPairRequest.Merge(m, src)
}
func (m *GetActiveTradingPairRequest) XXX_Size() int {
	return xxx_messageInfo_GetActiveTradingPairRequest.Size(m)
}
func (m *GetActiveTradingPairRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetActiveTradingPairRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetActiveTradingPairRequest proto.InternalMessageInfo

type GetActiveTradingPairResponse struct {
	PairId               []string `protobuf:"bytes,1,rep,name=pairId,proto3" json:"pairId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetActiveTradingPairResponse) Reset()         { *m = GetActiveTradingPairResponse{} }
func (m *GetActiveTradingPairResponse) String() string { return proto.CompactTextString(m) }
func (*GetActiveTradingPairResponse) ProtoMessage()    {}
func (*GetActiveTradingPairResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_197ef81533ed7ae1, []int{8}
}

func (m *GetActiveTradingPairResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetActiveTradingPairResponse.Unmarshal(m, b)
}
func (m *GetActiveTradingPairResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetActiveTradingPairResponse.Marshal(b, m, deterministic)
}
func (m *GetActiveTradingPairResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetActiveTradingPairResponse.Merge(m, src)
}
func (m *GetActiveTradingPairResponse) XXX_Size() int {
	return xxx_messageInfo_GetActiveTradingPairResponse.Size(m)
}
func (m *GetActiveTradingPairResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetActiveTradingPairResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetActiveTradingPairResponse proto.InternalMessageInfo

func (m *GetActiveTradingPairResponse) GetPairId() []string {
	if m != nil {
		return m.PairId
	}
	return nil
}

type ListOrdersRequest struct {
	PairId               string   `protobuf:"bytes,1,opt,name=pairId,proto3" json:"pairId,omitempty"`
	IncludeOwnOrders     bool     `protobuf:"varint,2,opt,name=includeOwnOrders,proto3" json:"includeOwnOrders,omitempty"`
	Skip                 uint32   `protobuf:"varint,3,opt,name=skip,proto3" json:"skip,omitempty"`
	Limit                uint32   `protobuf:"varint,4,opt,name=limit,proto3" json:"limit,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListOrdersRequest) Reset()         { *m = ListOrdersRequest{} }
func (m *ListOrdersRequest) String() string { return proto.CompactTextString(m) }
func (*ListOrdersRequest) ProtoMessage()    {}
func (*ListOrdersRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_197ef81533ed7ae1, []int{9}
}

func (m *ListOrdersRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ListOrdersRequest.Unmarshal(m, b)
}
func (m *ListOrdersRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ListOrdersRequest.Marshal(b, m, deterministic)
}
func (m *ListOrdersRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListOrdersRequest.Merge(m, src)
}
func (m *ListOrdersRequest) XXX_Size() int {
	return xxx_messageInfo_ListOrdersRequest.Size(m)
}
func (m *ListOrdersRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListOrdersRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListOrdersRequest proto.InternalMessageInfo

func (m *ListOrdersRequest) GetPairId() string {
	if m != nil {
		return m.PairId
	}
	return ""
}

func (m *ListOrdersRequest) GetIncludeOwnOrders() bool {
	if m != nil {
		return m.IncludeOwnOrders
	}
	return false
}

func (m *ListOrdersRequest) GetSkip() uint32 {
	if m != nil {
		return m.Skip
	}
	return 0
}

func (m *ListOrdersRequest) GetLimit() uint32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

type ListOrdersResponse struct {
	Orders               []*Order `protobuf:"bytes,1,rep,name=orders,proto3" json:"orders,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListOrdersResponse) Reset()         { *m = ListOrdersResponse{} }
func (m *ListOrdersResponse) String() string { return proto.CompactTextString(m) }
func (*ListOrdersResponse) ProtoMessage()    {}
func (*ListOrdersResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_197ef81533ed7ae1, []int{10}
}

func (m *ListOrdersResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ListOrdersResponse.Unmarshal(m, b)
}
func (m *ListOrdersResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ListOrdersResponse.Marshal(b, m, deterministic)
}
func (m *ListOrdersResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListOrdersResponse.Merge(m, src)
}
func (m *ListOrdersResponse) XXX_Size() int {
	return xxx_messageInfo_ListOrdersResponse.Size(m)
}
func (m *ListOrdersResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListOrdersResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListOrdersResponse proto.InternalMessageInfo

func (m *ListOrdersResponse) GetOrders() []*Order {
	if m != nil {
		return m.Orders
	}
	return nil
}

type PlaceOrderRequest struct {
	PairId               string      `protobuf:"bytes,1,opt,name=pairId,proto3" json:"pairId,omitempty"`
	Side                 OrderSide   `protobuf:"varint,2,opt,name=side,proto3,enum=lssdrpc.OrderSide" json:"side,omitempty"`
	Funds                *BigInteger `protobuf:"bytes,3,opt,name=funds,proto3" json:"funds,omitempty"`
	Price                *BigInteger `protobuf:"bytes,4,opt,name=price,proto3" json:"price,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *PlaceOrderRequest) Reset()         { *m = PlaceOrderRequest{} }
func (m *PlaceOrderRequest) String() string { return proto.CompactTextString(m) }
func (*PlaceOrderRequest) ProtoMessage()    {}
func (*PlaceOrderRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_197ef81533ed7ae1, []int{11}
}

func (m *PlaceOrderRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PlaceOrderRequest.Unmarshal(m, b)
}
func (m *PlaceOrderRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PlaceOrderRequest.Marshal(b, m, deterministic)
}
func (m *PlaceOrderRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PlaceOrderRequest.Merge(m, src)
}
func (m *PlaceOrderRequest) XXX_Size() int {
	return xxx_messageInfo_PlaceOrderRequest.Size(m)
}
func (m *PlaceOrderRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_PlaceOrderRequest.DiscardUnknown(m)
}

var xxx_messageInfo_PlaceOrderRequest proto.InternalMessageInfo

func (m *PlaceOrderRequest) GetPairId() string {
	if m != nil {
		return m.PairId
	}
	return ""
}

func (m *PlaceOrderRequest) GetSide() OrderSide {
	if m != nil {
		return m.Side
	}
	return OrderSide_buy
}

func (m *PlaceOrderRequest) GetFunds() *BigInteger {
	if m != nil {
		return m.Funds
	}
	return nil
}

func (m *PlaceOrderRequest) GetPrice() *BigInteger {
	if m != nil {
		return m.Price
	}
	return nil
}

// Outcome of place order, three possible situations
// 1. Order was placed
// 2. Order was placed and matched without going to orderbook
// 3. Place order or swap has failed
type PlaceOrderResponse struct {
	// Types that are valid to be assigned to Outcome:
	//	*PlaceOrderResponse_SwapSuccess
	//	*PlaceOrderResponse_Order
	//	*PlaceOrderResponse_Failure
	Outcome              isPlaceOrderResponse_Outcome `protobuf_oneof:"outcome"`
	XXX_NoUnkeyedLiteral struct{}                     `json:"-"`
	XXX_unrecognized     []byte                       `json:"-"`
	XXX_sizecache        int32                        `json:"-"`
}

func (m *PlaceOrderResponse) Reset()         { *m = PlaceOrderResponse{} }
func (m *PlaceOrderResponse) String() string { return proto.CompactTextString(m) }
func (*PlaceOrderResponse) ProtoMessage()    {}
func (*PlaceOrderResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_197ef81533ed7ae1, []int{12}
}

func (m *PlaceOrderResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PlaceOrderResponse.Unmarshal(m, b)
}
func (m *PlaceOrderResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PlaceOrderResponse.Marshal(b, m, deterministic)
}
func (m *PlaceOrderResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PlaceOrderResponse.Merge(m, src)
}
func (m *PlaceOrderResponse) XXX_Size() int {
	return xxx_messageInfo_PlaceOrderResponse.Size(m)
}
func (m *PlaceOrderResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_PlaceOrderResponse.DiscardUnknown(m)
}

var xxx_messageInfo_PlaceOrderResponse proto.InternalMessageInfo

type isPlaceOrderResponse_Outcome interface {
	isPlaceOrderResponse_Outcome()
}

type PlaceOrderResponse_SwapSuccess struct {
	SwapSuccess *SwapSuccess `protobuf:"bytes,1,opt,name=swapSuccess,proto3,oneof"`
}

type PlaceOrderResponse_Order struct {
	Order *Order `protobuf:"bytes,2,opt,name=order,proto3,oneof"`
}

type PlaceOrderResponse_Failure struct {
	Failure *PlaceOrderFailure `protobuf:"bytes,3,opt,name=failure,proto3,oneof"`
}

func (*PlaceOrderResponse_SwapSuccess) isPlaceOrderResponse_Outcome() {}

func (*PlaceOrderResponse_Order) isPlaceOrderResponse_Outcome() {}

func (*PlaceOrderResponse_Failure) isPlaceOrderResponse_Outcome() {}

func (m *PlaceOrderResponse) GetOutcome() isPlaceOrderResponse_Outcome {
	if m != nil {
		return m.Outcome
	}
	return nil
}

func (m *PlaceOrderResponse) GetSwapSuccess() *SwapSuccess {
	if x, ok := m.GetOutcome().(*PlaceOrderResponse_SwapSuccess); ok {
		return x.SwapSuccess
	}
	return nil
}

func (m *PlaceOrderResponse) GetOrder() *Order {
	if x, ok := m.GetOutcome().(*PlaceOrderResponse_Order); ok {
		return x.Order
	}
	return nil
}

func (m *PlaceOrderResponse) GetFailure() *PlaceOrderFailure {
	if x, ok := m.GetOutcome().(*PlaceOrderResponse_Failure); ok {
		return x.Failure
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*PlaceOrderResponse) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*PlaceOrderResponse_SwapSuccess)(nil),
		(*PlaceOrderResponse_Order)(nil),
		(*PlaceOrderResponse_Failure)(nil),
	}
}

type OrderbookFailure struct {
	PairId               string      `protobuf:"bytes,1,opt,name=pairId,proto3" json:"pairId,omitempty"`
	Funds                *BigInteger `protobuf:"bytes,2,opt,name=funds,proto3" json:"funds,omitempty"`
	FailureReason        string      `protobuf:"bytes,3,opt,name=failureReason,proto3" json:"failureReason,omitempty"`
	RequiredFee          *BigInteger `protobuf:"bytes,4,opt,name=requiredFee,proto3" json:"requiredFee,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *OrderbookFailure) Reset()         { *m = OrderbookFailure{} }
func (m *OrderbookFailure) String() string { return proto.CompactTextString(m) }
func (*OrderbookFailure) ProtoMessage()    {}
func (*OrderbookFailure) Descriptor() ([]byte, []int) {
	return fileDescriptor_197ef81533ed7ae1, []int{13}
}

func (m *OrderbookFailure) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_OrderbookFailure.Unmarshal(m, b)
}
func (m *OrderbookFailure) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_OrderbookFailure.Marshal(b, m, deterministic)
}
func (m *OrderbookFailure) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OrderbookFailure.Merge(m, src)
}
func (m *OrderbookFailure) XXX_Size() int {
	return xxx_messageInfo_OrderbookFailure.Size(m)
}
func (m *OrderbookFailure) XXX_DiscardUnknown() {
	xxx_messageInfo_OrderbookFailure.DiscardUnknown(m)
}

var xxx_messageInfo_OrderbookFailure proto.InternalMessageInfo

func (m *OrderbookFailure) GetPairId() string {
	if m != nil {
		return m.PairId
	}
	return ""
}

func (m *OrderbookFailure) GetFunds() *BigInteger {
	if m != nil {
		return m.Funds
	}
	return nil
}

func (m *OrderbookFailure) GetFailureReason() string {
	if m != nil {
		return m.FailureReason
	}
	return ""
}

func (m *OrderbookFailure) GetRequiredFee() *BigInteger {
	if m != nil {
		return m.RequiredFee
	}
	return nil
}

type PlaceOrderFailure struct {
	// Types that are valid to be assigned to Failure:
	//	*PlaceOrderFailure_SwapFailure
	//	*PlaceOrderFailure_OrderbookFailure
	Failure              isPlaceOrderFailure_Failure `protobuf_oneof:"failure"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *PlaceOrderFailure) Reset()         { *m = PlaceOrderFailure{} }
func (m *PlaceOrderFailure) String() string { return proto.CompactTextString(m) }
func (*PlaceOrderFailure) ProtoMessage()    {}
func (*PlaceOrderFailure) Descriptor() ([]byte, []int) {
	return fileDescriptor_197ef81533ed7ae1, []int{14}
}

func (m *PlaceOrderFailure) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PlaceOrderFailure.Unmarshal(m, b)
}
func (m *PlaceOrderFailure) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PlaceOrderFailure.Marshal(b, m, deterministic)
}
func (m *PlaceOrderFailure) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PlaceOrderFailure.Merge(m, src)
}
func (m *PlaceOrderFailure) XXX_Size() int {
	return xxx_messageInfo_PlaceOrderFailure.Size(m)
}
func (m *PlaceOrderFailure) XXX_DiscardUnknown() {
	xxx_messageInfo_PlaceOrderFailure.DiscardUnknown(m)
}

var xxx_messageInfo_PlaceOrderFailure proto.InternalMessageInfo

type isPlaceOrderFailure_Failure interface {
	isPlaceOrderFailure_Failure()
}

type PlaceOrderFailure_SwapFailure struct {
	SwapFailure *SwapFailure `protobuf:"bytes,1,opt,name=swapFailure,proto3,oneof"`
}

type PlaceOrderFailure_OrderbookFailure struct {
	OrderbookFailure *OrderbookFailure `protobuf:"bytes,2,opt,name=orderbookFailure,proto3,oneof"`
}

func (*PlaceOrderFailure_SwapFailure) isPlaceOrderFailure_Failure() {}

func (*PlaceOrderFailure_OrderbookFailure) isPlaceOrderFailure_Failure() {}

func (m *PlaceOrderFailure) GetFailure() isPlaceOrderFailure_Failure {
	if m != nil {
		return m.Failure
	}
	return nil
}

func (m *PlaceOrderFailure) GetSwapFailure() *SwapFailure {
	if x, ok := m.GetFailure().(*PlaceOrderFailure_SwapFailure); ok {
		return x.SwapFailure
	}
	return nil
}

func (m *PlaceOrderFailure) GetOrderbookFailure() *OrderbookFailure {
	if x, ok := m.GetFailure().(*PlaceOrderFailure_OrderbookFailure); ok {
		return x.OrderbookFailure
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*PlaceOrderFailure) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*PlaceOrderFailure_SwapFailure)(nil),
		(*PlaceOrderFailure_OrderbookFailure)(nil),
	}
}

type CancelOrderRequest struct {
	PairId               string   `protobuf:"bytes,1,opt,name=pairId,proto3" json:"pairId,omitempty"`
	OrderId              string   `protobuf:"bytes,2,opt,name=orderId,proto3" json:"orderId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CancelOrderRequest) Reset()         { *m = CancelOrderRequest{} }
func (m *CancelOrderRequest) String() string { return proto.CompactTextString(m) }
func (*CancelOrderRequest) ProtoMessage()    {}
func (*CancelOrderRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_197ef81533ed7ae1, []int{15}
}

func (m *CancelOrderRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CancelOrderRequest.Unmarshal(m, b)
}
func (m *CancelOrderRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CancelOrderRequest.Marshal(b, m, deterministic)
}
func (m *CancelOrderRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CancelOrderRequest.Merge(m, src)
}
func (m *CancelOrderRequest) XXX_Size() int {
	return xxx_messageInfo_CancelOrderRequest.Size(m)
}
func (m *CancelOrderRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CancelOrderRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CancelOrderRequest proto.InternalMessageInfo

func (m *CancelOrderRequest) GetPairId() string {
	if m != nil {
		return m.PairId
	}
	return ""
}

func (m *CancelOrderRequest) GetOrderId() string {
	if m != nil {
		return m.OrderId
	}
	return ""
}

type CancelOrderResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CancelOrderResponse) Reset()         { *m = CancelOrderResponse{} }
func (m *CancelOrderResponse) String() string { return proto.CompactTextString(m) }
func (*CancelOrderResponse) ProtoMessage()    {}
func (*CancelOrderResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_197ef81533ed7ae1, []int{16}
}

func (m *CancelOrderResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CancelOrderResponse.Unmarshal(m, b)
}
func (m *CancelOrderResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CancelOrderResponse.Marshal(b, m, deterministic)
}
func (m *CancelOrderResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CancelOrderResponse.Merge(m, src)
}
func (m *CancelOrderResponse) XXX_Size() int {
	return xxx_messageInfo_CancelOrderResponse.Size(m)
}
func (m *CancelOrderResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CancelOrderResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CancelOrderResponse proto.InternalMessageInfo

type SubscribeOrdersRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SubscribeOrdersRequest) Reset()         { *m = SubscribeOrdersRequest{} }
func (m *SubscribeOrdersRequest) String() string { return proto.CompactTextString(m) }
func (*SubscribeOrdersRequest) ProtoMessage()    {}
func (*SubscribeOrdersRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_197ef81533ed7ae1, []int{17}
}

func (m *SubscribeOrdersRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SubscribeOrdersRequest.Unmarshal(m, b)
}
func (m *SubscribeOrdersRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SubscribeOrdersRequest.Marshal(b, m, deterministic)
}
func (m *SubscribeOrdersRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubscribeOrdersRequest.Merge(m, src)
}
func (m *SubscribeOrdersRequest) XXX_Size() int {
	return xxx_messageInfo_SubscribeOrdersRequest.Size(m)
}
func (m *SubscribeOrdersRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SubscribeOrdersRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SubscribeOrdersRequest proto.InternalMessageInfo

type OrderUpdate struct {
	// Types that are valid to be assigned to Update:
	//	*OrderUpdate_OrderAdded
	//	*OrderUpdate_OrderRemoval
	Update               isOrderUpdate_Update `protobuf_oneof:"update"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *OrderUpdate) Reset()         { *m = OrderUpdate{} }
func (m *OrderUpdate) String() string { return proto.CompactTextString(m) }
func (*OrderUpdate) ProtoMessage()    {}
func (*OrderUpdate) Descriptor() ([]byte, []int) {
	return fileDescriptor_197ef81533ed7ae1, []int{18}
}

func (m *OrderUpdate) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_OrderUpdate.Unmarshal(m, b)
}
func (m *OrderUpdate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_OrderUpdate.Marshal(b, m, deterministic)
}
func (m *OrderUpdate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OrderUpdate.Merge(m, src)
}
func (m *OrderUpdate) XXX_Size() int {
	return xxx_messageInfo_OrderUpdate.Size(m)
}
func (m *OrderUpdate) XXX_DiscardUnknown() {
	xxx_messageInfo_OrderUpdate.DiscardUnknown(m)
}

var xxx_messageInfo_OrderUpdate proto.InternalMessageInfo

type isOrderUpdate_Update interface {
	isOrderUpdate_Update()
}

type OrderUpdate_OrderAdded struct {
	OrderAdded *Order `protobuf:"bytes,1,opt,name=orderAdded,proto3,oneof"`
}

type OrderUpdate_OrderRemoval struct {
	OrderRemoval *Order `protobuf:"bytes,2,opt,name=orderRemoval,proto3,oneof"`
}

func (*OrderUpdate_OrderAdded) isOrderUpdate_Update() {}

func (*OrderUpdate_OrderRemoval) isOrderUpdate_Update() {}

func (m *OrderUpdate) GetUpdate() isOrderUpdate_Update {
	if m != nil {
		return m.Update
	}
	return nil
}

func (m *OrderUpdate) GetOrderAdded() *Order {
	if x, ok := m.GetUpdate().(*OrderUpdate_OrderAdded); ok {
		return x.OrderAdded
	}
	return nil
}

func (m *OrderUpdate) GetOrderRemoval() *Order {
	if x, ok := m.GetUpdate().(*OrderUpdate_OrderRemoval); ok {
		return x.OrderRemoval
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*OrderUpdate) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*OrderUpdate_OrderAdded)(nil),
		(*OrderUpdate_OrderRemoval)(nil),
	}
}

type OwnOrderUpdate struct {
	// Types that are valid to be assigned to Update:
	//	*OwnOrderUpdate_OrderAdded
	//	*OwnOrderUpdate_OrderChanged
	//	*OwnOrderUpdate_OrderCompleted
	Update               isOwnOrderUpdate_Update `protobuf_oneof:"update"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *OwnOrderUpdate) Reset()         { *m = OwnOrderUpdate{} }
func (m *OwnOrderUpdate) String() string { return proto.CompactTextString(m) }
func (*OwnOrderUpdate) ProtoMessage()    {}
func (*OwnOrderUpdate) Descriptor() ([]byte, []int) {
	return fileDescriptor_197ef81533ed7ae1, []int{19}
}

func (m *OwnOrderUpdate) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_OwnOrderUpdate.Unmarshal(m, b)
}
func (m *OwnOrderUpdate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_OwnOrderUpdate.Marshal(b, m, deterministic)
}
func (m *OwnOrderUpdate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OwnOrderUpdate.Merge(m, src)
}
func (m *OwnOrderUpdate) XXX_Size() int {
	return xxx_messageInfo_OwnOrderUpdate.Size(m)
}
func (m *OwnOrderUpdate) XXX_DiscardUnknown() {
	xxx_messageInfo_OwnOrderUpdate.DiscardUnknown(m)
}

var xxx_messageInfo_OwnOrderUpdate proto.InternalMessageInfo

type isOwnOrderUpdate_Update interface {
	isOwnOrderUpdate_Update()
}

type OwnOrderUpdate_OrderAdded struct {
	OrderAdded *Order `protobuf:"bytes,1,opt,name=orderAdded,proto3,oneof"`
}

type OwnOrderUpdate_OrderChanged struct {
	OrderChanged *Order `protobuf:"bytes,2,opt,name=orderChanged,proto3,oneof"`
}

type OwnOrderUpdate_OrderCompleted struct {
	OrderCompleted string `protobuf:"bytes,3,opt,name=orderCompleted,proto3,oneof"`
}

func (*OwnOrderUpdate_OrderAdded) isOwnOrderUpdate_Update() {}

func (*OwnOrderUpdate_OrderChanged) isOwnOrderUpdate_Update() {}

func (*OwnOrderUpdate_OrderCompleted) isOwnOrderUpdate_Update() {}

func (m *OwnOrderUpdate) GetUpdate() isOwnOrderUpdate_Update {
	if m != nil {
		return m.Update
	}
	return nil
}

func (m *OwnOrderUpdate) GetOrderAdded() *Order {
	if x, ok := m.GetUpdate().(*OwnOrderUpdate_OrderAdded); ok {
		return x.OrderAdded
	}
	return nil
}

func (m *OwnOrderUpdate) GetOrderChanged() *Order {
	if x, ok := m.GetUpdate().(*OwnOrderUpdate_OrderChanged); ok {
		return x.OrderChanged
	}
	return nil
}

func (m *OwnOrderUpdate) GetOrderCompleted() string {
	if x, ok := m.GetUpdate().(*OwnOrderUpdate_OrderCompleted); ok {
		return x.OrderCompleted
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*OwnOrderUpdate) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*OwnOrderUpdate_OrderAdded)(nil),
		(*OwnOrderUpdate_OrderChanged)(nil),
		(*OwnOrderUpdate_OrderCompleted)(nil),
	}
}

type Order struct {
	PairId  string `protobuf:"bytes,1,opt,name=pairId,proto3" json:"pairId,omitempty"`
	OrderId string `protobuf:"bytes,2,opt,name=orderId,proto3" json:"orderId,omitempty"`
	// The price of the order in satoshis.
	Price *BigInteger `protobuf:"bytes,3,opt,name=price,proto3" json:"price,omitempty"`
	// The funds of the order in satoshis.
	Funds *BigInteger `protobuf:"bytes,4,opt,name=funds,proto3" json:"funds,omitempty"`
	// The epoch time when this order was created.
	CreatedAt uint64 `protobuf:"varint,5,opt,name=createdAt,proto3" json:"createdAt,omitempty"`
	// Whether this order is a buy or sell
	Side OrderSide `protobuf:"varint,6,opt,name=side,proto3,enum=lssdrpc.OrderSide" json:"side,omitempty"`
	// Whether this order is a local own order or a remote peer order.
	IsOwnOrder bool `protobuf:"varint,7,opt,name=isOwnOrder,proto3" json:"isOwnOrder,omitempty"`
	// Currently open partial trades, empty if order hasn't posted any partial trades.
	Open []*OrderPortion `protobuf:"bytes,8,rep,name=open,proto3" json:"open,omitempty"`
	// Already completed partial trades, empty if order hasn't completed any partial trades.
	Closed               []*OrderPortion `protobuf:"bytes,9,rep,name=closed,proto3" json:"closed,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *Order) Reset()         { *m = Order{} }
func (m *Order) String() string { return proto.CompactTextString(m) }
func (*Order) ProtoMessage()    {}
func (*Order) Descriptor() ([]byte, []int) {
	return fileDescriptor_197ef81533ed7ae1, []int{20}
}

func (m *Order) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Order.Unmarshal(m, b)
}
func (m *Order) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Order.Marshal(b, m, deterministic)
}
func (m *Order) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Order.Merge(m, src)
}
func (m *Order) XXX_Size() int {
	return xxx_messageInfo_Order.Size(m)
}
func (m *Order) XXX_DiscardUnknown() {
	xxx_messageInfo_Order.DiscardUnknown(m)
}

var xxx_messageInfo_Order proto.InternalMessageInfo

func (m *Order) GetPairId() string {
	if m != nil {
		return m.PairId
	}
	return ""
}

func (m *Order) GetOrderId() string {
	if m != nil {
		return m.OrderId
	}
	return ""
}

func (m *Order) GetPrice() *BigInteger {
	if m != nil {
		return m.Price
	}
	return nil
}

func (m *Order) GetFunds() *BigInteger {
	if m != nil {
		return m.Funds
	}
	return nil
}

func (m *Order) GetCreatedAt() uint64 {
	if m != nil {
		return m.CreatedAt
	}
	return 0
}

func (m *Order) GetSide() OrderSide {
	if m != nil {
		return m.Side
	}
	return OrderSide_buy
}

func (m *Order) GetIsOwnOrder() bool {
	if m != nil {
		return m.IsOwnOrder
	}
	return false
}

func (m *Order) GetOpen() []*OrderPortion {
	if m != nil {
		return m.Open
	}
	return nil
}

func (m *Order) GetClosed() []*OrderPortion {
	if m != nil {
		return m.Closed
	}
	return nil
}

type OrderPortion struct {
	OrderId              string      `protobuf:"bytes,1,opt,name=orderId,proto3" json:"orderId,omitempty"`
	Amount               *BigInteger `protobuf:"bytes,2,opt,name=amount,proto3" json:"amount,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *OrderPortion) Reset()         { *m = OrderPortion{} }
func (m *OrderPortion) String() string { return proto.CompactTextString(m) }
func (*OrderPortion) ProtoMessage()    {}
func (*OrderPortion) Descriptor() ([]byte, []int) {
	return fileDescriptor_197ef81533ed7ae1, []int{21}
}

func (m *OrderPortion) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_OrderPortion.Unmarshal(m, b)
}
func (m *OrderPortion) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_OrderPortion.Marshal(b, m, deterministic)
}
func (m *OrderPortion) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OrderPortion.Merge(m, src)
}
func (m *OrderPortion) XXX_Size() int {
	return xxx_messageInfo_OrderPortion.Size(m)
}
func (m *OrderPortion) XXX_DiscardUnknown() {
	xxx_messageInfo_OrderPortion.DiscardUnknown(m)
}

var xxx_messageInfo_OrderPortion proto.InternalMessageInfo

func (m *OrderPortion) GetOrderId() string {
	if m != nil {
		return m.OrderId
	}
	return ""
}

func (m *OrderPortion) GetAmount() *BigInteger {
	if m != nil {
		return m.Amount
	}
	return nil
}

type SubscribeSwapsRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SubscribeSwapsRequest) Reset()         { *m = SubscribeSwapsRequest{} }
func (m *SubscribeSwapsRequest) String() string { return proto.CompactTextString(m) }
func (*SubscribeSwapsRequest) ProtoMessage()    {}
func (*SubscribeSwapsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_197ef81533ed7ae1, []int{22}
}

func (m *SubscribeSwapsRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SubscribeSwapsRequest.Unmarshal(m, b)
}
func (m *SubscribeSwapsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SubscribeSwapsRequest.Marshal(b, m, deterministic)
}
func (m *SubscribeSwapsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubscribeSwapsRequest.Merge(m, src)
}
func (m *SubscribeSwapsRequest) XXX_Size() int {
	return xxx_messageInfo_SubscribeSwapsRequest.Size(m)
}
func (m *SubscribeSwapsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SubscribeSwapsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SubscribeSwapsRequest proto.InternalMessageInfo

type SwapResult struct {
	// Types that are valid to be assigned to Value:
	//	*SwapResult_Success
	//	*SwapResult_Failure
	Value                isSwapResult_Value `protobuf_oneof:"value"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *SwapResult) Reset()         { *m = SwapResult{} }
func (m *SwapResult) String() string { return proto.CompactTextString(m) }
func (*SwapResult) ProtoMessage()    {}
func (*SwapResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_197ef81533ed7ae1, []int{23}
}

func (m *SwapResult) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SwapResult.Unmarshal(m, b)
}
func (m *SwapResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SwapResult.Marshal(b, m, deterministic)
}
func (m *SwapResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SwapResult.Merge(m, src)
}
func (m *SwapResult) XXX_Size() int {
	return xxx_messageInfo_SwapResult.Size(m)
}
func (m *SwapResult) XXX_DiscardUnknown() {
	xxx_messageInfo_SwapResult.DiscardUnknown(m)
}

var xxx_messageInfo_SwapResult proto.InternalMessageInfo

type isSwapResult_Value interface {
	isSwapResult_Value()
}

type SwapResult_Success struct {
	Success *SwapSuccess `protobuf:"bytes,1,opt,name=success,proto3,oneof"`
}

type SwapResult_Failure struct {
	Failure *SwapFailure `protobuf:"bytes,2,opt,name=failure,proto3,oneof"`
}

func (*SwapResult_Success) isSwapResult_Value() {}

func (*SwapResult_Failure) isSwapResult_Value() {}

func (m *SwapResult) GetValue() isSwapResult_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *SwapResult) GetSuccess() *SwapSuccess {
	if x, ok := m.GetValue().(*SwapResult_Success); ok {
		return x.Success
	}
	return nil
}

func (m *SwapResult) GetFailure() *SwapFailure {
	if x, ok := m.GetValue().(*SwapResult_Failure); ok {
		return x.Failure
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*SwapResult) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*SwapResult_Success)(nil),
		(*SwapResult_Failure)(nil),
	}
}

type SwapSuccess struct {
	// Order id assigned by orderbook
	OrderId string `protobuf:"bytes,1,opt,name=orderId,proto3" json:"orderId,omitempty"`
	// The trading pair that the swap is for.
	PairId string `protobuf:"bytes,2,opt,name=pairId,proto3" json:"pairId,omitempty"`
	// The order funds that was swapped.
	Funds *BigInteger `protobuf:"bytes,3,opt,name=funds,proto3" json:"funds,omitempty"`
	// The hex-encoded payment hash for the swap.
	RHash string `protobuf:"bytes,4,opt,name=rHash,proto3" json:"rHash,omitempty"`
	// The amount received denominated in satoshis.
	AmountReceived *BigInteger `protobuf:"bytes,5,opt,name=amountReceived,proto3" json:"amountReceived,omitempty"`
	// The amount sent denominated in satoshis.
	AmountSent *BigInteger `protobuf:"bytes,6,opt,name=amountSent,proto3" json:"amountSent,omitempty"`
	// Our role in the swap, either MAKER or TAKER.
	Role SwapSuccess_Role `protobuf:"varint,7,opt,name=role,proto3,enum=lssdrpc.SwapSuccess_Role" json:"role,omitempty"`
	// The ticker symbol of the currency received.
	CurrencyReceived string `protobuf:"bytes,8,opt,name=currencyReceived,proto3" json:"currencyReceived,omitempty"`
	// The ticker symbol of the currency sent.
	CurrencySent string `protobuf:"bytes,9,opt,name=currencySent,proto3" json:"currencySent,omitempty"`
	// The hex-encoded preimage.
	RPreimage string `protobuf:"bytes,10,opt,name=rPreimage,proto3" json:"rPreimage,omitempty"`
	// The price used for the swap.
	Price                *BigInteger `protobuf:"bytes,11,opt,name=price,proto3" json:"price,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *SwapSuccess) Reset()         { *m = SwapSuccess{} }
func (m *SwapSuccess) String() string { return proto.CompactTextString(m) }
func (*SwapSuccess) ProtoMessage()    {}
func (*SwapSuccess) Descriptor() ([]byte, []int) {
	return fileDescriptor_197ef81533ed7ae1, []int{24}
}

func (m *SwapSuccess) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SwapSuccess.Unmarshal(m, b)
}
func (m *SwapSuccess) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SwapSuccess.Marshal(b, m, deterministic)
}
func (m *SwapSuccess) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SwapSuccess.Merge(m, src)
}
func (m *SwapSuccess) XXX_Size() int {
	return xxx_messageInfo_SwapSuccess.Size(m)
}
func (m *SwapSuccess) XXX_DiscardUnknown() {
	xxx_messageInfo_SwapSuccess.DiscardUnknown(m)
}

var xxx_messageInfo_SwapSuccess proto.InternalMessageInfo

func (m *SwapSuccess) GetOrderId() string {
	if m != nil {
		return m.OrderId
	}
	return ""
}

func (m *SwapSuccess) GetPairId() string {
	if m != nil {
		return m.PairId
	}
	return ""
}

func (m *SwapSuccess) GetFunds() *BigInteger {
	if m != nil {
		return m.Funds
	}
	return nil
}

func (m *SwapSuccess) GetRHash() string {
	if m != nil {
		return m.RHash
	}
	return ""
}

func (m *SwapSuccess) GetAmountReceived() *BigInteger {
	if m != nil {
		return m.AmountReceived
	}
	return nil
}

func (m *SwapSuccess) GetAmountSent() *BigInteger {
	if m != nil {
		return m.AmountSent
	}
	return nil
}

func (m *SwapSuccess) GetRole() SwapSuccess_Role {
	if m != nil {
		return m.Role
	}
	return SwapSuccess_TAKER
}

func (m *SwapSuccess) GetCurrencyReceived() string {
	if m != nil {
		return m.CurrencyReceived
	}
	return ""
}

func (m *SwapSuccess) GetCurrencySent() string {
	if m != nil {
		return m.CurrencySent
	}
	return ""
}

func (m *SwapSuccess) GetRPreimage() string {
	if m != nil {
		return m.RPreimage
	}
	return ""
}

func (m *SwapSuccess) GetPrice() *BigInteger {
	if m != nil {
		return m.Price
	}
	return nil
}

type SwapFailure struct {
	// Order id assigned by orderbook
	OrderId string `protobuf:"bytes,1,opt,name=orderId,proto3" json:"orderId,omitempty"`
	// The trading pair that the swap is for.
	PairId string `protobuf:"bytes,2,opt,name=pairId,proto3" json:"pairId,omitempty"`
	// The order funds that was attempted to be swapped.
	Funds *BigInteger `protobuf:"bytes,3,opt,name=funds,proto3" json:"funds,omitempty"`
	// The reason why the swap failed.
	FailureReason        string   `protobuf:"bytes,4,opt,name=failureReason,proto3" json:"failureReason,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SwapFailure) Reset()         { *m = SwapFailure{} }
func (m *SwapFailure) String() string { return proto.CompactTextString(m) }
func (*SwapFailure) ProtoMessage()    {}
func (*SwapFailure) Descriptor() ([]byte, []int) {
	return fileDescriptor_197ef81533ed7ae1, []int{25}
}

func (m *SwapFailure) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SwapFailure.Unmarshal(m, b)
}
func (m *SwapFailure) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SwapFailure.Marshal(b, m, deterministic)
}
func (m *SwapFailure) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SwapFailure.Merge(m, src)
}
func (m *SwapFailure) XXX_Size() int {
	return xxx_messageInfo_SwapFailure.Size(m)
}
func (m *SwapFailure) XXX_DiscardUnknown() {
	xxx_messageInfo_SwapFailure.DiscardUnknown(m)
}

var xxx_messageInfo_SwapFailure proto.InternalMessageInfo

func (m *SwapFailure) GetOrderId() string {
	if m != nil {
		return m.OrderId
	}
	return ""
}

func (m *SwapFailure) GetPairId() string {
	if m != nil {
		return m.PairId
	}
	return ""
}

func (m *SwapFailure) GetFunds() *BigInteger {
	if m != nil {
		return m.Funds
	}
	return nil
}

func (m *SwapFailure) GetFailureReason() string {
	if m != nil {
		return m.FailureReason
	}
	return ""
}

// The command to create an invoice to pay the channel rental
type GenerateInvoiceToRentChannelCommand struct {
	Currency             string      `protobuf:"bytes,1,opt,name=currency,proto3" json:"currency,omitempty"`
	PayingCurrency       string      `protobuf:"bytes,2,opt,name=payingCurrency,proto3" json:"payingCurrency,omitempty"`
	Capacity             *BigInteger `protobuf:"bytes,3,opt,name=capacity,proto3" json:"capacity,omitempty"`
	LifetimeSeconds      int64       `protobuf:"varint,4,opt,name=lifetimeSeconds,proto3" json:"lifetimeSeconds,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *GenerateInvoiceToRentChannelCommand) Reset()         { *m = GenerateInvoiceToRentChannelCommand{} }
func (m *GenerateInvoiceToRentChannelCommand) String() string { return proto.CompactTextString(m) }
func (*GenerateInvoiceToRentChannelCommand) ProtoMessage()    {}
func (*GenerateInvoiceToRentChannelCommand) Descriptor() ([]byte, []int) {
	return fileDescriptor_197ef81533ed7ae1, []int{26}
}

func (m *GenerateInvoiceToRentChannelCommand) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GenerateInvoiceToRentChannelCommand.Unmarshal(m, b)
}
func (m *GenerateInvoiceToRentChannelCommand) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GenerateInvoiceToRentChannelCommand.Marshal(b, m, deterministic)
}
func (m *GenerateInvoiceToRentChannelCommand) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GenerateInvoiceToRentChannelCommand.Merge(m, src)
}
func (m *GenerateInvoiceToRentChannelCommand) XXX_Size() int {
	return xxx_messageInfo_GenerateInvoiceToRentChannelCommand.Size(m)
}
func (m *GenerateInvoiceToRentChannelCommand) XXX_DiscardUnknown() {
	xxx_messageInfo_GenerateInvoiceToRentChannelCommand.DiscardUnknown(m)
}

var xxx_messageInfo_GenerateInvoiceToRentChannelCommand proto.InternalMessageInfo

func (m *GenerateInvoiceToRentChannelCommand) GetCurrency() string {
	if m != nil {
		return m.Currency
	}
	return ""
}

func (m *GenerateInvoiceToRentChannelCommand) GetPayingCurrency() string {
	if m != nil {
		return m.PayingCurrency
	}
	return ""
}

func (m *GenerateInvoiceToRentChannelCommand) GetCapacity() *BigInteger {
	if m != nil {
		return m.Capacity
	}
	return nil
}

func (m *GenerateInvoiceToRentChannelCommand) GetLifetimeSeconds() int64 {
	if m != nil {
		return m.LifetimeSeconds
	}
	return 0
}

// Event for GenerateInvoiceToRentChannelCommand
type GenerateInvoiceToRentChannelResponse struct {
	PaymentRequest       string   `protobuf:"bytes,1,opt,name=paymentRequest,proto3" json:"paymentRequest,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GenerateInvoiceToRentChannelResponse) Reset()         { *m = GenerateInvoiceToRentChannelResponse{} }
func (m *GenerateInvoiceToRentChannelResponse) String() string { return proto.CompactTextString(m) }
func (*GenerateInvoiceToRentChannelResponse) ProtoMessage()    {}
func (*GenerateInvoiceToRentChannelResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_197ef81533ed7ae1, []int{27}
}

func (m *GenerateInvoiceToRentChannelResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GenerateInvoiceToRentChannelResponse.Unmarshal(m, b)
}
func (m *GenerateInvoiceToRentChannelResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GenerateInvoiceToRentChannelResponse.Marshal(b, m, deterministic)
}
func (m *GenerateInvoiceToRentChannelResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GenerateInvoiceToRentChannelResponse.Merge(m, src)
}
func (m *GenerateInvoiceToRentChannelResponse) XXX_Size() int {
	return xxx_messageInfo_GenerateInvoiceToRentChannelResponse.Size(m)
}
func (m *GenerateInvoiceToRentChannelResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GenerateInvoiceToRentChannelResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GenerateInvoiceToRentChannelResponse proto.InternalMessageInfo

func (m *GenerateInvoiceToRentChannelResponse) GetPaymentRequest() string {
	if m != nil {
		return m.PaymentRequest
	}
	return ""
}

// Ask the server to create a channel with a given node
// The channel details are stored with GenerateInvoiceToRentChannelCommand
// - Response is RentChannelResponse
type RentChannelCommand struct {
	PaymentHash          []byte   `protobuf:"bytes,1,opt,name=paymentHash,proto3" json:"paymentHash,omitempty"`
	PayingCurrency       string   `protobuf:"bytes,2,opt,name=payingCurrency,proto3" json:"payingCurrency,omitempty"`
	NodePublicKey        []byte   `protobuf:"bytes,3,opt,name=nodePublicKey,proto3" json:"nodePublicKey,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RentChannelCommand) Reset()         { *m = RentChannelCommand{} }
func (m *RentChannelCommand) String() string { return proto.CompactTextString(m) }
func (*RentChannelCommand) ProtoMessage()    {}
func (*RentChannelCommand) Descriptor() ([]byte, []int) {
	return fileDescriptor_197ef81533ed7ae1, []int{28}
}

func (m *RentChannelCommand) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RentChannelCommand.Unmarshal(m, b)
}
func (m *RentChannelCommand) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RentChannelCommand.Marshal(b, m, deterministic)
}
func (m *RentChannelCommand) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RentChannelCommand.Merge(m, src)
}
func (m *RentChannelCommand) XXX_Size() int {
	return xxx_messageInfo_RentChannelCommand.Size(m)
}
func (m *RentChannelCommand) XXX_DiscardUnknown() {
	xxx_messageInfo_RentChannelCommand.DiscardUnknown(m)
}

var xxx_messageInfo_RentChannelCommand proto.InternalMessageInfo

func (m *RentChannelCommand) GetPaymentHash() []byte {
	if m != nil {
		return m.PaymentHash
	}
	return nil
}

func (m *RentChannelCommand) GetPayingCurrency() string {
	if m != nil {
		return m.PayingCurrency
	}
	return ""
}

func (m *RentChannelCommand) GetNodePublicKey() []byte {
	if m != nil {
		return m.NodePublicKey
	}
	return nil
}

// Event for RentChannelCommand
type RentChannelResponse struct {
	ChannelId            string   `protobuf:"bytes,1,opt,name=channelId,proto3" json:"channelId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RentChannelResponse) Reset()         { *m = RentChannelResponse{} }
func (m *RentChannelResponse) String() string { return proto.CompactTextString(m) }
func (*RentChannelResponse) ProtoMessage()    {}
func (*RentChannelResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_197ef81533ed7ae1, []int{29}
}

func (m *RentChannelResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RentChannelResponse.Unmarshal(m, b)
}
func (m *RentChannelResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RentChannelResponse.Marshal(b, m, deterministic)
}
func (m *RentChannelResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RentChannelResponse.Merge(m, src)
}
func (m *RentChannelResponse) XXX_Size() int {
	return xxx_messageInfo_RentChannelResponse.Size(m)
}
func (m *RentChannelResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RentChannelResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RentChannelResponse proto.InternalMessageInfo

func (m *RentChannelResponse) GetChannelId() string {
	if m != nil {
		return m.ChannelId
	}
	return ""
}

// Command to know the status of a channel.
type GetChannelStatusCommand struct {
	ChannelId            string   `protobuf:"bytes,1,opt,name=channelId,proto3" json:"channelId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetChannelStatusCommand) Reset()         { *m = GetChannelStatusCommand{} }
func (m *GetChannelStatusCommand) String() string { return proto.CompactTextString(m) }
func (*GetChannelStatusCommand) ProtoMessage()    {}
func (*GetChannelStatusCommand) Descriptor() ([]byte, []int) {
	return fileDescriptor_197ef81533ed7ae1, []int{30}
}

func (m *GetChannelStatusCommand) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetChannelStatusCommand.Unmarshal(m, b)
}
func (m *GetChannelStatusCommand) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetChannelStatusCommand.Marshal(b, m, deterministic)
}
func (m *GetChannelStatusCommand) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetChannelStatusCommand.Merge(m, src)
}
func (m *GetChannelStatusCommand) XXX_Size() int {
	return xxx_messageInfo_GetChannelStatusCommand.Size(m)
}
func (m *GetChannelStatusCommand) XXX_DiscardUnknown() {
	xxx_messageInfo_GetChannelStatusCommand.DiscardUnknown(m)
}

var xxx_messageInfo_GetChannelStatusCommand proto.InternalMessageInfo

func (m *GetChannelStatusCommand) GetChannelId() string {
	if m != nil {
		return m.ChannelId
	}
	return ""
}

// Event for GetChannelStatusCommand
type GetChannelStatusResponse struct {
	Status               string   `protobuf:"bytes,1,opt,name=status,proto3" json:"status,omitempty"`
	ExpiresAt            int64    `protobuf:"varint,2,opt,name=expiresAt,proto3" json:"expiresAt,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetChannelStatusResponse) Reset()         { *m = GetChannelStatusResponse{} }
func (m *GetChannelStatusResponse) String() string { return proto.CompactTextString(m) }
func (*GetChannelStatusResponse) ProtoMessage()    {}
func (*GetChannelStatusResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_197ef81533ed7ae1, []int{31}
}

func (m *GetChannelStatusResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetChannelStatusResponse.Unmarshal(m, b)
}
func (m *GetChannelStatusResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetChannelStatusResponse.Marshal(b, m, deterministic)
}
func (m *GetChannelStatusResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetChannelStatusResponse.Merge(m, src)
}
func (m *GetChannelStatusResponse) XXX_Size() int {
	return xxx_messageInfo_GetChannelStatusResponse.Size(m)
}
func (m *GetChannelStatusResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetChannelStatusResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetChannelStatusResponse proto.InternalMessageInfo

func (m *GetChannelStatusResponse) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *GetChannelStatusResponse) GetExpiresAt() int64 {
	if m != nil {
		return m.ExpiresAt
	}
	return 0
}

// The command to calculate the fee to rent a channel
type GetFeeToRentChannelCommand struct {
	Currency             string      `protobuf:"bytes,1,opt,name=currency,proto3" json:"currency,omitempty"`
	PayingCurrency       string      `protobuf:"bytes,2,opt,name=payingCurrency,proto3" json:"payingCurrency,omitempty"`
	Capacity             *BigInteger `protobuf:"bytes,3,opt,name=capacity,proto3" json:"capacity,omitempty"`
	LifetimeSeconds      int64       `protobuf:"varint,4,opt,name=lifetimeSeconds,proto3" json:"lifetimeSeconds,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *GetFeeToRentChannelCommand) Reset()         { *m = GetFeeToRentChannelCommand{} }
func (m *GetFeeToRentChannelCommand) String() string { return proto.CompactTextString(m) }
func (*GetFeeToRentChannelCommand) ProtoMessage()    {}
func (*GetFeeToRentChannelCommand) Descriptor() ([]byte, []int) {
	return fileDescriptor_197ef81533ed7ae1, []int{32}
}

func (m *GetFeeToRentChannelCommand) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetFeeToRentChannelCommand.Unmarshal(m, b)
}
func (m *GetFeeToRentChannelCommand) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetFeeToRentChannelCommand.Marshal(b, m, deterministic)
}
func (m *GetFeeToRentChannelCommand) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetFeeToRentChannelCommand.Merge(m, src)
}
func (m *GetFeeToRentChannelCommand) XXX_Size() int {
	return xxx_messageInfo_GetFeeToRentChannelCommand.Size(m)
}
func (m *GetFeeToRentChannelCommand) XXX_DiscardUnknown() {
	xxx_messageInfo_GetFeeToRentChannelCommand.DiscardUnknown(m)
}

var xxx_messageInfo_GetFeeToRentChannelCommand proto.InternalMessageInfo

func (m *GetFeeToRentChannelCommand) GetCurrency() string {
	if m != nil {
		return m.Currency
	}
	return ""
}

func (m *GetFeeToRentChannelCommand) GetPayingCurrency() string {
	if m != nil {
		return m.PayingCurrency
	}
	return ""
}

func (m *GetFeeToRentChannelCommand) GetCapacity() *BigInteger {
	if m != nil {
		return m.Capacity
	}
	return nil
}

func (m *GetFeeToRentChannelCommand) GetLifetimeSeconds() int64 {
	if m != nil {
		return m.LifetimeSeconds
	}
	return 0
}

// Event for GenerateInvoiceToRentChannelCommand
type GetFeeToRentChannelResponse struct {
	Fee                  *BigInteger `protobuf:"bytes,1,opt,name=fee,proto3" json:"fee,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *GetFeeToRentChannelResponse) Reset()         { *m = GetFeeToRentChannelResponse{} }
func (m *GetFeeToRentChannelResponse) String() string { return proto.CompactTextString(m) }
func (*GetFeeToRentChannelResponse) ProtoMessage()    {}
func (*GetFeeToRentChannelResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_197ef81533ed7ae1, []int{33}
}

func (m *GetFeeToRentChannelResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetFeeToRentChannelResponse.Unmarshal(m, b)
}
func (m *GetFeeToRentChannelResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetFeeToRentChannelResponse.Marshal(b, m, deterministic)
}
func (m *GetFeeToRentChannelResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetFeeToRentChannelResponse.Merge(m, src)
}
func (m *GetFeeToRentChannelResponse) XXX_Size() int {
	return xxx_messageInfo_GetFeeToRentChannelResponse.Size(m)
}
func (m *GetFeeToRentChannelResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetFeeToRentChannelResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetFeeToRentChannelResponse proto.InternalMessageInfo

func (m *GetFeeToRentChannelResponse) GetFee() *BigInteger {
	if m != nil {
		return m.Fee
	}
	return nil
}

func init() {
	proto.RegisterEnum("lssdrpc.OrderSide", OrderSide_name, OrderSide_value)
	proto.RegisterEnum("lssdrpc.SwapSuccess_Role", SwapSuccess_Role_name, SwapSuccess_Role_value)
	proto.RegisterType((*BigInteger)(nil), "lssdrpc.BigInteger")
	proto.RegisterType((*AddCurrencyRequest)(nil), "lssdrpc.AddCurrencyRequest")
	proto.RegisterType((*AddCurrencyResponse)(nil), "lssdrpc.AddCurrencyResponse")
	proto.RegisterType((*GetAddedCurrenciesRequest)(nil), "lssdrpc.GetAddedCurrenciesRequest")
	proto.RegisterType((*GetAddedCurrenciesResponse)(nil), "lssdrpc.GetAddedCurrenciesResponse")
	proto.RegisterType((*EnableTradingPairRequest)(nil), "lssdrpc.EnableTradingPairRequest")
	proto.RegisterType((*EnableTradingPairResponse)(nil), "lssdrpc.EnableTradingPairResponse")
	proto.RegisterType((*GetActiveTradingPairRequest)(nil), "lssdrpc.GetActiveTradingPairRequest")
	proto.RegisterType((*GetActiveTradingPairResponse)(nil), "lssdrpc.GetActiveTradingPairResponse")
	proto.RegisterType((*ListOrdersRequest)(nil), "lssdrpc.ListOrdersRequest")
	proto.RegisterType((*ListOrdersResponse)(nil), "lssdrpc.ListOrdersResponse")
	proto.RegisterType((*PlaceOrderRequest)(nil), "lssdrpc.PlaceOrderRequest")
	proto.RegisterType((*PlaceOrderResponse)(nil), "lssdrpc.PlaceOrderResponse")
	proto.RegisterType((*OrderbookFailure)(nil), "lssdrpc.OrderbookFailure")
	proto.RegisterType((*PlaceOrderFailure)(nil), "lssdrpc.PlaceOrderFailure")
	proto.RegisterType((*CancelOrderRequest)(nil), "lssdrpc.CancelOrderRequest")
	proto.RegisterType((*CancelOrderResponse)(nil), "lssdrpc.CancelOrderResponse")
	proto.RegisterType((*SubscribeOrdersRequest)(nil), "lssdrpc.SubscribeOrdersRequest")
	proto.RegisterType((*OrderUpdate)(nil), "lssdrpc.OrderUpdate")
	proto.RegisterType((*OwnOrderUpdate)(nil), "lssdrpc.OwnOrderUpdate")
	proto.RegisterType((*Order)(nil), "lssdrpc.Order")
	proto.RegisterType((*OrderPortion)(nil), "lssdrpc.OrderPortion")
	proto.RegisterType((*SubscribeSwapsRequest)(nil), "lssdrpc.SubscribeSwapsRequest")
	proto.RegisterType((*SwapResult)(nil), "lssdrpc.SwapResult")
	proto.RegisterType((*SwapSuccess)(nil), "lssdrpc.SwapSuccess")
	proto.RegisterType((*SwapFailure)(nil), "lssdrpc.SwapFailure")
	proto.RegisterType((*GenerateInvoiceToRentChannelCommand)(nil), "lssdrpc.GenerateInvoiceToRentChannelCommand")
	proto.RegisterType((*GenerateInvoiceToRentChannelResponse)(nil), "lssdrpc.GenerateInvoiceToRentChannelResponse")
	proto.RegisterType((*RentChannelCommand)(nil), "lssdrpc.RentChannelCommand")
	proto.RegisterType((*RentChannelResponse)(nil), "lssdrpc.RentChannelResponse")
	proto.RegisterType((*GetChannelStatusCommand)(nil), "lssdrpc.GetChannelStatusCommand")
	proto.RegisterType((*GetChannelStatusResponse)(nil), "lssdrpc.GetChannelStatusResponse")
	proto.RegisterType((*GetFeeToRentChannelCommand)(nil), "lssdrpc.GetFeeToRentChannelCommand")
	proto.RegisterType((*GetFeeToRentChannelResponse)(nil), "lssdrpc.GetFeeToRentChannelResponse")
}

func init() {
	proto.RegisterFile("lssdrpc.proto", fileDescriptor_197ef81533ed7ae1)
}

var fileDescriptor_197ef81533ed7ae1 = []byte{
	// 1561 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xd4, 0x58, 0x4d, 0x8f, 0xdc, 0x44,
	0x13, 0x8e, 0x77, 0xbe, 0x76, 0x6a, 0x76, 0x27, 0x9b, 0xde, 0x4d, 0x32, 0x99, 0xdd, 0x37, 0x6f,
	0xd2, 0xd9, 0x44, 0x21, 0x90, 0x10, 0x4d, 0x20, 0x44, 0x82, 0xcb, 0x66, 0xc9, 0x17, 0x01, 0x32,
	0xf2, 0x24, 0x42, 0x42, 0x42, 0xc2, 0x63, 0xf7, 0x6e, 0xac, 0x78, 0x6c, 0xe3, 0xb6, 0xb3, 0xcc,
	0x09, 0x21, 0x71, 0xe1, 0xc6, 0x85, 0x1f, 0xc0, 0x11, 0x89, 0x13, 0x12, 0x07, 0xc4, 0x95, 0x7b,
	0xae, 0xfc, 0x1a, 0x44, 0x7f, 0xd9, 0x6e, 0x8f, 0x3d, 0x33, 0x8b, 0x10, 0x07, 0x6e, 0xd3, 0x55,
	0x4f, 0x97, 0x9f, 0xaa, 0xae, 0xae, 0xae, 0x1a, 0x58, 0xf7, 0x28, 0x75, 0xa2, 0xd0, 0xbe, 0x11,
	0x46, 0x41, 0x1c, 0xa0, 0x96, 0x5a, 0x62, 0x0c, 0x70, 0xd7, 0x3d, 0x7c, 0xe4, 0xc7, 0xe4, 0x90,
	0x44, 0x68, 0x0b, 0x1a, 0x2f, 0x2d, 0x2f, 0x21, 0x3d, 0xe3, 0x82, 0x71, 0xb5, 0x6d, 0xca, 0x05,
	0xfe, 0xde, 0x00, 0xb4, 0xe7, 0x38, 0xfb, 0x49, 0x14, 0x11, 0xdf, 0x9e, 0x9a, 0xe4, 0x8b, 0x84,
	0xd0, 0x18, 0xf5, 0x61, 0xd5, 0x56, 0x22, 0x85, 0xcf, 0xd6, 0xe8, 0x3c, 0x80, 0xe7, 0x3b, 0xfb,
	0xcf, 0x2d, 0xdf, 0x27, 0x5e, 0x6f, 0x45, 0x68, 0x35, 0x09, 0xda, 0x61, 0x7b, 0x49, 0x14, 0x0f,
	0xad, 0xf8, 0x79, 0xaf, 0xc6, 0xb5, 0x0f, 0x4f, 0x98, 0x99, 0x84, 0x59, 0x6e, 0x45, 0xd6, 0xd1,
	0x3e, 0x5b, 0xf6, 0xea, 0x4a, 0x99, 0x0a, 0xee, 0xb6, 0xa1, 0x15, 0x7b, 0x94, 0xff, 0xc4, 0xa7,
	0x61, 0xb3, 0x40, 0x8b, 0x86, 0x81, 0x4f, 0x09, 0xde, 0x86, 0x73, 0x0f, 0x48, 0xcc, 0x34, 0x24,
	0xd5, 0xb9, 0x84, 0x2a, 0xd2, 0xf8, 0x0e, 0xf4, 0xab, 0x94, 0x72, 0xeb, 0x8c, 0x4b, 0x35, 0xdd,
	0x25, 0x3c, 0x80, 0xde, 0x3d, 0xdf, 0x1a, 0x7b, 0xe4, 0x69, 0x64, 0x39, 0xae, 0x7f, 0x38, 0xb4,
	0xdc, 0x28, 0x0d, 0xc5, 0x19, 0x68, 0x86, 0x6c, 0xf9, 0xc8, 0x51, 0x81, 0x50, 0x2b, 0x4e, 0xa5,
	0x62, 0x8f, 0xe2, 0xf9, 0x3f, 0xd8, 0xe6, 0x54, 0xec, 0xd8, 0x7d, 0x59, 0x61, 0x13, 0xdf, 0x86,
	0x9d, 0x6a, 0xb5, 0xe2, 0xaa, 0x7f, 0xb3, 0xa6, 0x7d, 0xf3, 0x6b, 0x03, 0x4e, 0x7d, 0xe8, 0xd2,
	0xf8, 0x49, 0xe4, 0x90, 0x88, 0x2e, 0x61, 0x88, 0xae, 0xc1, 0x86, 0xeb, 0xdb, 0x5e, 0xe2, 0x90,
	0x27, 0x47, 0xbe, 0xdc, 0x22, 0x8e, 0x6b, 0xd5, 0x2c, 0xc9, 0x11, 0x82, 0x3a, 0x7d, 0xe1, 0x86,
	0xe2, 0xc0, 0xd6, 0x4d, 0xf1, 0x9b, 0x67, 0x8c, 0xe7, 0x4e, 0x5c, 0x79, 0x50, 0xeb, 0xa6, 0x5c,
	0xe0, 0xf7, 0x00, 0xe9, 0x14, 0x14, 0xe3, 0x2b, 0xd0, 0x0c, 0xe4, 0x17, 0x38, 0xe3, 0xce, 0xa0,
	0x7b, 0x23, 0x4d, 0x4a, 0x01, 0x34, 0x95, 0x16, 0xff, 0xc8, 0x3c, 0x18, 0x7a, 0x96, 0x4d, 0xa4,
	0x78, 0x89, 0x07, 0x57, 0x18, 0x2b, 0xd7, 0x21, 0x82, 0x75, 0x77, 0x80, 0x8a, 0x36, 0x47, 0x4c,
	0x63, 0x0a, 0x3d, 0x7a, 0x0d, 0x1a, 0x07, 0x89, 0xef, 0x50, 0x41, 0xbf, 0x33, 0xd8, 0xcc, 0x80,
	0x79, 0xfe, 0x9b, 0x12, 0xc1, 0xa1, 0x61, 0xe4, 0xda, 0x44, 0x38, 0x35, 0x0f, 0x2a, 0x10, 0xf8,
	0x57, 0x76, 0x37, 0x74, 0xae, 0xca, 0xd5, 0x3b, 0xd0, 0xa1, 0x47, 0x56, 0x38, 0x4a, 0x6c, 0x9b,
	0x50, 0x2a, 0x18, 0x77, 0x06, 0x5b, 0x99, 0x9d, 0x51, 0xae, 0x63, 0xb9, 0xad, 0x43, 0x99, 0x3b,
	0x0d, 0x11, 0x06, 0xe1, 0x4f, 0x29, 0x46, 0x0c, 0x2d, 0xd5, 0xe8, 0x36, 0xb4, 0x0e, 0x2c, 0xd7,
	0x4b, 0x22, 0xa2, 0x1c, 0xea, 0x67, 0xc8, 0x9c, 0xcf, 0x7d, 0x89, 0xe0, 0xf7, 0x47, 0x81, 0xf9,
	0xfd, 0x09, 0x92, 0xd8, 0x0e, 0x26, 0x04, 0xff, 0x6c, 0xc0, 0x86, 0x80, 0x8d, 0x83, 0xe0, 0x85,
	0x82, 0xce, 0x0d, 0x73, 0x16, 0xbe, 0x95, 0xa5, 0xe1, 0xdb, 0x85, 0x75, 0xf5, 0x35, 0x93, 0x58,
	0x34, 0xf0, 0xe5, 0x0d, 0x37, 0x8b, 0x42, 0xf4, 0x36, 0x74, 0x22, 0x76, 0xb4, 0x6e, 0x44, 0x9c,
	0xfb, 0x64, 0x61, 0xa8, 0x75, 0x1c, 0xfe, 0xa1, 0x90, 0x1c, 0x29, 0x6b, 0x15, 0x6f, 0xb5, 0xac,
	0x8c, 0x77, 0x1e, 0x0b, 0x1d, 0x8a, 0x1e, 0xc0, 0x46, 0x30, 0x13, 0x03, 0xe5, 0xe2, 0xb9, 0x62,
	0xe8, 0x35, 0x00, 0xb3, 0x51, 0xda, 0xc4, 0x03, 0xab, 0x1c, 0xc4, 0xf7, 0x01, 0xed, 0x5b, 0xbe,
	0x4d, 0xbc, 0x63, 0x25, 0x70, 0x8f, 0x9d, 0x08, 0xc7, 0x31, 0x85, 0x2c, 0x94, 0xe9, 0x92, 0x17,
	0xb8, 0x82, 0x1d, 0x55, 0x38, 0x7a, 0x70, 0x66, 0x94, 0x8c, 0xa9, 0x1d, 0xb9, 0x63, 0x52, 0xb8,
	0xe5, 0xf8, 0x2b, 0xe8, 0x08, 0xc1, 0xb3, 0xd0, 0xb1, 0x62, 0x82, 0x6e, 0x02, 0x08, 0x53, 0xa2,
	0xdc, 0xa9, 0xa0, 0x94, 0x13, 0x4a, 0xc3, 0xa0, 0xb7, 0x60, 0x2d, 0x90, 0xdf, 0x9a, 0x04, 0xac,
	0xf8, 0xcf, 0x4d, 0xc2, 0x02, 0xea, 0xee, 0x2a, 0x34, 0x13, 0xf1, 0x45, 0xfc, 0x93, 0x01, 0xdd,
	0xb4, 0x60, 0xfc, 0x63, 0x12, 0xfc, 0xb1, 0x38, 0x24, 0xce, 0x12, 0x12, 0x0a, 0x85, 0xae, 0x42,
	0x57, 0xae, 0x83, 0x49, 0xe8, 0x91, 0x98, 0xed, 0x4b, 0x1f, 0x96, 0x19, 0xb9, 0x46, 0xf7, 0xd5,
	0x0a, 0x34, 0x84, 0xb5, 0xbf, 0x7f, 0x38, 0x79, 0x91, 0xa8, 0x2d, 0x2b, 0x12, 0xf9, 0xdd, 0xa9,
	0x2f, 0xbd, 0x3b, 0x3b, 0xd0, 0xb6, 0x23, 0xc2, 0xb8, 0x39, 0x7b, 0x71, 0xaf, 0xc1, 0xe0, 0x75,
	0x33, 0x17, 0x64, 0xb5, 0xae, 0xb9, 0xa4, 0xd6, 0xb1, 0xe7, 0xd7, 0xa5, 0xe9, 0x39, 0xf4, 0x5a,
	0xa2, 0x9e, 0x6b, 0x12, 0x46, 0xa8, 0x1e, 0x84, 0xc4, 0xef, 0xad, 0x8a, 0x3a, 0x7c, 0xba, 0x68,
	0x67, 0x18, 0x44, 0xb1, 0x1b, 0xf8, 0xa6, 0x80, 0xa0, 0xeb, 0xd0, 0xb4, 0xbd, 0x80, 0xb2, 0x70,
	0xb6, 0x17, 0x81, 0x15, 0x08, 0x3f, 0x83, 0x35, 0x5d, 0xae, 0xc7, 0xcf, 0x28, 0xc6, 0xef, 0x75,
	0x68, 0x5a, 0x93, 0x20, 0xf1, 0xe3, 0x45, 0x15, 0x45, 0x41, 0xf0, 0x59, 0x38, 0x9d, 0xa5, 0x3c,
	0xbf, 0xcc, 0x59, 0xc6, 0x4f, 0x01, 0xf8, 0x9a, 0xdd, 0x8d, 0xc4, 0x8b, 0x59, 0xae, 0xb5, 0xe8,
	0xb1, 0x4a, 0x6e, 0x0a, 0xe3, 0x3b, 0x0e, 0x0a, 0xb7, 0x7e, 0x5e, 0xd1, 0xc8, 0x0a, 0x68, 0x4b,
	0xf5, 0x48, 0xf8, 0x8f, 0x1a, 0x74, 0x34, 0xab, 0x0b, 0x5c, 0xcd, 0x93, 0x6b, 0xa5, 0xba, 0xa6,
	0x2e, 0x7f, 0x92, 0xd8, 0x3b, 0x1b, 0x3d, 0xb4, 0xe8, 0x73, 0xd9, 0x10, 0x99, 0x72, 0x81, 0xde,
	0x85, 0xae, 0x0c, 0x90, 0x49, 0x6c, 0xc2, 0xfa, 0x04, 0x47, 0xa4, 0xcc, 0x1c, 0x4b, 0x33, 0x50,
	0x74, 0x0b, 0x40, 0x4a, 0x46, 0x84, 0x1d, 0x42, 0x73, 0xfe, 0x46, 0x0d, 0xc6, 0xd2, 0xa1, 0x1e,
	0x05, 0x1e, 0x11, 0x39, 0xd5, 0xd5, 0x4a, 0xa4, 0x16, 0x88, 0x1b, 0x26, 0x03, 0x98, 0x02, 0xc6,
	0xdb, 0x0b, 0x3b, 0xeb, 0xcf, 0x14, 0xc5, 0x55, 0xe1, 0x41, 0x49, 0x8e, 0x30, 0xac, 0xa5, 0x32,
	0xc1, 0xa8, 0x2d, 0x70, 0x05, 0x19, 0xbf, 0x1e, 0xd1, 0x30, 0x22, 0xee, 0xc4, 0x3a, 0x24, 0x3d,
	0x10, 0x80, 0x5c, 0x90, 0x5f, 0xc9, 0xce, 0xd2, 0x77, 0x7b, 0x07, 0xea, 0x9c, 0x26, 0x6a, 0x43,
	0xe3, 0xe9, 0xde, 0xe3, 0x7b, 0xe6, 0xc6, 0x09, 0xfe, 0xf3, 0x23, 0xf1, 0xd3, 0xc0, 0xdf, 0x19,
	0xf2, 0x68, 0xd3, 0x47, 0xe2, 0x5f, 0x3d, 0xda, 0xd2, 0x73, 0x59, 0xaf, 0x78, 0x2e, 0xf1, 0xef,
	0x06, 0x5c, 0x7a, 0x40, 0x7c, 0x12, 0xb1, 0x52, 0xf0, 0xc8, 0x7f, 0x19, 0x30, 0x27, 0x9e, 0x06,
	0x26, 0x8b, 0x89, 0x6a, 0xa9, 0x59, 0x79, 0x9b, 0x58, 0xbe, 0xb3, 0xb0, 0x2b, 0xbf, 0x02, 0xdd,
	0xd0, 0x9a, 0xb2, 0x46, 0x32, 0xed, 0x99, 0x15, 0xe9, 0x19, 0x29, 0x7a, 0x93, 0xd9, 0xb0, 0x42,
	0xcb, 0x76, 0xe3, 0xe9, 0x22, 0xfe, 0x19, 0x88, 0xd5, 0xde, 0x93, 0x9e, 0x7b, 0x40, 0x62, 0x77,
	0x42, 0x46, 0xc4, 0x0e, 0xd2, 0x52, 0x57, 0x33, 0x67, 0xc5, 0xf8, 0x63, 0xd8, 0x5d, 0xe4, 0x85,
	0xd6, 0x2b, 0x72, 0x52, 0x13, 0xc2, 0xf3, 0x55, 0xdc, 0x74, 0xe5, 0xcc, 0x8c, 0x14, 0x7f, 0xc3,
	0xfa, 0xaf, 0x8a, 0x28, 0x5c, 0x80, 0x8e, 0x02, 0x8a, 0x4b, 0xc3, 0xf7, 0xae, 0x99, 0xba, 0xe8,
	0xd8, 0xb1, 0x60, 0xa7, 0xe3, 0x07, 0x0e, 0x19, 0x26, 0x63, 0xcf, 0xb5, 0x1f, 0x13, 0x19, 0x90,
	0x35, 0xb3, 0x28, 0xc4, 0xb7, 0x60, 0xb3, 0xca, 0x0b, 0x5e, 0xcd, 0xa5, 0x28, 0xcb, 0x9c, 0x5c,
	0x80, 0xdf, 0x81, 0xb3, 0xac, 0xc3, 0x57, 0x7b, 0x46, 0xb1, 0x15, 0x27, 0x34, 0xe5, 0xbf, 0x78,
	0xe3, 0x10, 0x7a, 0xb3, 0x1b, 0xf5, 0xb1, 0x80, 0x0a, 0x49, 0xfa, 0x90, 0xc9, 0x15, 0xb7, 0x48,
	0xbe, 0x0c, 0x59, 0x17, 0x45, 0xf7, 0x64, 0xc5, 0xad, 0x99, 0xb9, 0x00, 0xff, 0x66, 0x88, 0xb9,
	0x88, 0x35, 0x58, 0xff, 0xc5, 0xa4, 0x7a, 0x5f, 0x4c, 0x52, 0xb3, 0xe4, 0xb3, 0x90, 0x5c, 0x86,
	0xda, 0x01, 0x49, 0x9b, 0xc2, 0xca, 0x8f, 0x72, 0xfd, 0xb5, 0xf3, 0xd0, 0xce, 0xde, 0x51, 0xd4,
	0x82, 0xda, 0x38, 0x99, 0xb2, 0xaa, 0xb0, 0xca, 0x9e, 0x5c, 0xe2, 0x79, 0x1b, 0xc6, 0xe0, 0x17,
	0x03, 0xc0, 0xce, 0x66, 0x46, 0xf4, 0x10, 0x3a, 0xda, 0xf4, 0x89, 0xb6, 0x33, 0xbb, 0xe5, 0x51,
	0xb9, 0xbf, 0x53, 0xad, 0x54, 0xfc, 0x3e, 0x03, 0x54, 0x9e, 0x49, 0x11, 0xce, 0xf6, 0xcc, 0x9d,
	0x66, 0xfb, 0x97, 0x16, 0x62, 0xa4, 0xf9, 0xc1, 0x2b, 0x03, 0xd6, 0xe2, 0x7c, 0x80, 0xa4, 0xe8,
	0x53, 0x38, 0x55, 0x9a, 0x4a, 0xd1, 0xc5, 0xcc, 0xd4, 0xbc, 0x29, 0xb7, 0x8f, 0x17, 0x41, 0x94,
	0x2f, 0x36, 0x6c, 0x55, 0x4d, 0xad, 0x68, 0xb7, 0xc0, 0x74, 0xce, 0xcc, 0xdb, 0xbf, 0xbc, 0x04,
	0xa5, 0x3c, 0xfa, 0x73, 0x25, 0x9d, 0x24, 0xd1, 0x3d, 0x80, 0x7c, 0x1a, 0x40, 0x55, 0x33, 0x50,
	0x6a, 0x7b, 0xbb, 0x52, 0xa7, 0x68, 0xb3, 0xc3, 0xd4, 0x3a, 0x6d, 0xed, 0x30, 0xcb, 0x7d, 0xbc,
	0x76, 0x98, 0x15, 0xcd, 0x39, 0xfa, 0x00, 0x4e, 0xce, 0x34, 0xe7, 0xe8, 0xff, 0xf9, 0x2b, 0x59,
	0xd9, 0xb6, 0xf7, 0xb7, 0x8a, 0x3d, 0x95, 0x6c, 0x9c, 0x6f, 0x1a, 0x68, 0x08, 0x28, 0xdf, 0x91,
	0x8d, 0xe1, 0x4b, 0xcd, 0x9d, 0xcd, 0xcd, 0x15, 0x5a, 0x71, 0x66, 0x91, 0x85, 0x2b, 0x1f, 0xcc,
	0xb5, 0x70, 0x95, 0xfe, 0x30, 0xd0, 0xc2, 0x55, 0x9e, 0xe4, 0x07, 0x43, 0x68, 0xf0, 0x19, 0x8a,
	0xb2, 0xe9, 0xa9, 0x5b, 0xec, 0xcb, 0xd0, 0xf9, 0x32, 0x3b, 0xbd, 0x61, 0xeb, 0x6f, 0x16, 0x5a,
	0x06, 0xd9, 0xb7, 0xdd, 0x34, 0x06, 0xdf, 0xd6, 0xa0, 0xc5, 0x12, 0x37, 0x66, 0x47, 0x8d, 0xa6,
	0xbc, 0x16, 0xc9, 0x37, 0x42, 0xbb, 0xce, 0xea, 0xb9, 0x40, 0x6f, 0x68, 0x39, 0xb2, 0xf4, 0x39,
	0xec, 0x5f, 0x3f, 0x16, 0x5a, 0xcf, 0x03, 0x4d, 0xac, 0xe5, 0x41, 0x85, 0xe9, 0x9d, 0x2a, 0x65,
	0x66, 0xe9, 0x13, 0xd8, 0x98, 0xad, 0xd1, 0xe8, 0x82, 0x9e, 0xde, 0x55, 0x75, 0xbf, 0x7f, 0x71,
	0x2e, 0x22, 0x33, 0xfc, 0x39, 0x6c, 0x56, 0x14, 0x3b, 0x54, 0x28, 0x05, 0x73, 0xea, 0x78, 0x7f,
	0x77, 0x11, 0x28, 0xfd, 0xc2, 0xb8, 0x29, 0xfe, 0x23, 0xbc, 0xf5, 0x57, 0x00, 0x00, 0x00, 0xff,
	0xff, 0x57, 0x3a, 0xf5, 0xd4, 0x34, 0x14, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConnInterface

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion6

// CurrenciesClient is the client API for Currencies service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type CurrenciesClient interface {
	// before being able to enable a trading pair, you need to add the two involved currencies
	// for example, for activating XSN_LTC, you will add the XSN currency, and the LTC currency.
	//
	// For now, only currencies supported by lnd (lightning network) work.
	AddCurrency(ctx context.Context, in *AddCurrencyRequest, opts ...grpc.CallOption) (*AddCurrencyResponse, error)
	// Return added currencies, like LTC, before calling this method, you must
	// have already added some currency
	GetAddedCurrencies(ctx context.Context, in *GetAddedCurrenciesRequest, opts ...grpc.CallOption) (*GetAddedCurrenciesResponse, error)
}

type currenciesClient struct {
	cc grpc.ClientConnInterface
}

func NewCurrenciesClient(cc grpc.ClientConnInterface) CurrenciesClient {
	return &currenciesClient{cc}
}

func (c *currenciesClient) AddCurrency(ctx context.Context, in *AddCurrencyRequest, opts ...grpc.CallOption) (*AddCurrencyResponse, error) {
	out := new(AddCurrencyResponse)
	err := c.cc.Invoke(ctx, "/lssdrpc.currencies/AddCurrency", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *currenciesClient) GetAddedCurrencies(ctx context.Context, in *GetAddedCurrenciesRequest, opts ...grpc.CallOption) (*GetAddedCurrenciesResponse, error) {
	out := new(GetAddedCurrenciesResponse)
	err := c.cc.Invoke(ctx, "/lssdrpc.currencies/GetAddedCurrencies", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CurrenciesServer is the server API for Currencies service.
type CurrenciesServer interface {
	// before being able to enable a trading pair, you need to add the two involved currencies
	// for example, for activating XSN_LTC, you will add the XSN currency, and the LTC currency.
	//
	// For now, only currencies supported by lnd (lightning network) work.
	AddCurrency(context.Context, *AddCurrencyRequest) (*AddCurrencyResponse, error)
	// Return added currencies, like LTC, before calling this method, you must
	// have already added some currency
	GetAddedCurrencies(context.Context, *GetAddedCurrenciesRequest) (*GetAddedCurrenciesResponse, error)
}

// UnimplementedCurrenciesServer can be embedded to have forward compatible implementations.
type UnimplementedCurrenciesServer struct {
}

func (*UnimplementedCurrenciesServer) AddCurrency(ctx context.Context, req *AddCurrencyRequest) (*AddCurrencyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddCurrency not implemented")
}
func (*UnimplementedCurrenciesServer) GetAddedCurrencies(ctx context.Context, req *GetAddedCurrenciesRequest) (*GetAddedCurrenciesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAddedCurrencies not implemented")
}

func RegisterCurrenciesServer(s *grpc.Server, srv CurrenciesServer) {
	s.RegisterService(&_Currencies_serviceDesc, srv)
}

func _Currencies_AddCurrency_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddCurrencyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CurrenciesServer).AddCurrency(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lssdrpc.currencies/AddCurrency",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CurrenciesServer).AddCurrency(ctx, req.(*AddCurrencyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Currencies_GetAddedCurrencies_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAddedCurrenciesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CurrenciesServer).GetAddedCurrencies(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lssdrpc.currencies/GetAddedCurrencies",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CurrenciesServer).GetAddedCurrencies(ctx, req.(*GetAddedCurrenciesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Currencies_serviceDesc = grpc.ServiceDesc{
	ServiceName: "lssdrpc.currencies",
	HandlerType: (*CurrenciesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddCurrency",
			Handler:    _Currencies_AddCurrency_Handler,
		},
		{
			MethodName: "GetAddedCurrencies",
			Handler:    _Currencies_GetAddedCurrencies_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "lssdrpc.proto",
}

// TradingPairsClient is the client API for TradingPairs service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type TradingPairsClient interface {
	// Enables the given trading pair, like XSN_LTC, before calling this method, you must
	// have already added the involved currencies.
	//
	// After enabling a trading pair, lssd will download the existing orders form the orderbook,
	// try waiting some seconds (5 should be enough) before performing any other operation, so
	// that lssd has the time to sync because this is done in the background.
	EnableTradingPair(ctx context.Context, in *EnableTradingPairRequest, opts ...grpc.CallOption) (*EnableTradingPairResponse, error)
	// Return current active trading pair, like XSN_LTC, before calling this method, you must
	// have already added and activated some trading pair
	GetActiveTradingPair(ctx context.Context, in *GetActiveTradingPairRequest, opts ...grpc.CallOption) (*GetActiveTradingPairResponse, error)
}

type tradingPairsClient struct {
	cc grpc.ClientConnInterface
}

func NewTradingPairsClient(cc grpc.ClientConnInterface) TradingPairsClient {
	return &tradingPairsClient{cc}
}

func (c *tradingPairsClient) EnableTradingPair(ctx context.Context, in *EnableTradingPairRequest, opts ...grpc.CallOption) (*EnableTradingPairResponse, error) {
	out := new(EnableTradingPairResponse)
	err := c.cc.Invoke(ctx, "/lssdrpc.tradingPairs/EnableTradingPair", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradingPairsClient) GetActiveTradingPair(ctx context.Context, in *GetActiveTradingPairRequest, opts ...grpc.CallOption) (*GetActiveTradingPairResponse, error) {
	out := new(GetActiveTradingPairResponse)
	err := c.cc.Invoke(ctx, "/lssdrpc.tradingPairs/GetActiveTradingPair", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TradingPairsServer is the server API for TradingPairs service.
type TradingPairsServer interface {
	// Enables the given trading pair, like XSN_LTC, before calling this method, you must
	// have already added the involved currencies.
	//
	// After enabling a trading pair, lssd will download the existing orders form the orderbook,
	// try waiting some seconds (5 should be enough) before performing any other operation, so
	// that lssd has the time to sync because this is done in the background.
	EnableTradingPair(context.Context, *EnableTradingPairRequest) (*EnableTradingPairResponse, error)
	// Return current active trading pair, like XSN_LTC, before calling this method, you must
	// have already added and activated some trading pair
	GetActiveTradingPair(context.Context, *GetActiveTradingPairRequest) (*GetActiveTradingPairResponse, error)
}

// UnimplementedTradingPairsServer can be embedded to have forward compatible implementations.
type UnimplementedTradingPairsServer struct {
}

func (*UnimplementedTradingPairsServer) EnableTradingPair(ctx context.Context, req *EnableTradingPairRequest) (*EnableTradingPairResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EnableTradingPair not implemented")
}
func (*UnimplementedTradingPairsServer) GetActiveTradingPair(ctx context.Context, req *GetActiveTradingPairRequest) (*GetActiveTradingPairResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetActiveTradingPair not implemented")
}

func RegisterTradingPairsServer(s *grpc.Server, srv TradingPairsServer) {
	s.RegisterService(&_TradingPairs_serviceDesc, srv)
}

func _TradingPairs_EnableTradingPair_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EnableTradingPairRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradingPairsServer).EnableTradingPair(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lssdrpc.tradingPairs/EnableTradingPair",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradingPairsServer).EnableTradingPair(ctx, req.(*EnableTradingPairRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TradingPairs_GetActiveTradingPair_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetActiveTradingPairRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradingPairsServer).GetActiveTradingPair(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lssdrpc.tradingPairs/GetActiveTradingPair",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradingPairsServer).GetActiveTradingPair(ctx, req.(*GetActiveTradingPairRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _TradingPairs_serviceDesc = grpc.ServiceDesc{
	ServiceName: "lssdrpc.tradingPairs",
	HandlerType: (*TradingPairsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "EnableTradingPair",
			Handler:    _TradingPairs_EnableTradingPair_Handler,
		},
		{
			MethodName: "GetActiveTradingPair",
			Handler:    _TradingPairs_GetActiveTradingPair_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "lssdrpc.proto",
}

// OrdersClient is the client API for Orders service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type OrdersClient interface {
	// Places an order to the orderbook, you must have already enabled the involved trading pair.
	//
	// NOTE: After the order is matched, lssd will perform the swap automatically, so, your lnd
	// needs to have a channel with enough coins to our hub.
	PlaceOrder(ctx context.Context, in *PlaceOrderRequest, opts ...grpc.CallOption) (*PlaceOrderResponse, error)
	// Cancels an existing order.
	CancelOrder(ctx context.Context, in *CancelOrderRequest, opts ...grpc.CallOption) (*CancelOrderResponse, error)
	// Subscribe to events related to the orders in the orderbook.
	// Order added, removed will be delivered via this stream.
	SubscribeOrders(ctx context.Context, in *SubscribeOrdersRequest, opts ...grpc.CallOption) (Orders_SubscribeOrdersClient, error)
	// Subscribe to events related to the own oroders in the orderbook.
	// Order added, changed, removed will be delivered via this stream.
	SubscribeOwnOrders(ctx context.Context, in *SubscribeOrdersRequest, opts ...grpc.CallOption) (Orders_SubscribeOwnOrdersClient, error)
	// List the available order on the orderbook.
	ListOrders(ctx context.Context, in *ListOrdersRequest, opts ...grpc.CallOption) (*ListOrdersResponse, error)
}

type ordersClient struct {
	cc grpc.ClientConnInterface
}

func NewOrdersClient(cc grpc.ClientConnInterface) OrdersClient {
	return &ordersClient{cc}
}

func (c *ordersClient) PlaceOrder(ctx context.Context, in *PlaceOrderRequest, opts ...grpc.CallOption) (*PlaceOrderResponse, error) {
	out := new(PlaceOrderResponse)
	err := c.cc.Invoke(ctx, "/lssdrpc.orders/PlaceOrder", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ordersClient) CancelOrder(ctx context.Context, in *CancelOrderRequest, opts ...grpc.CallOption) (*CancelOrderResponse, error) {
	out := new(CancelOrderResponse)
	err := c.cc.Invoke(ctx, "/lssdrpc.orders/CancelOrder", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ordersClient) SubscribeOrders(ctx context.Context, in *SubscribeOrdersRequest, opts ...grpc.CallOption) (Orders_SubscribeOrdersClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Orders_serviceDesc.Streams[0], "/lssdrpc.orders/SubscribeOrders", opts...)
	if err != nil {
		return nil, err
	}
	x := &ordersSubscribeOrdersClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Orders_SubscribeOrdersClient interface {
	Recv() (*OrderUpdate, error)
	grpc.ClientStream
}

type ordersSubscribeOrdersClient struct {
	grpc.ClientStream
}

func (x *ordersSubscribeOrdersClient) Recv() (*OrderUpdate, error) {
	m := new(OrderUpdate)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *ordersClient) SubscribeOwnOrders(ctx context.Context, in *SubscribeOrdersRequest, opts ...grpc.CallOption) (Orders_SubscribeOwnOrdersClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Orders_serviceDesc.Streams[1], "/lssdrpc.orders/SubscribeOwnOrders", opts...)
	if err != nil {
		return nil, err
	}
	x := &ordersSubscribeOwnOrdersClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Orders_SubscribeOwnOrdersClient interface {
	Recv() (*OwnOrderUpdate, error)
	grpc.ClientStream
}

type ordersSubscribeOwnOrdersClient struct {
	grpc.ClientStream
}

func (x *ordersSubscribeOwnOrdersClient) Recv() (*OwnOrderUpdate, error) {
	m := new(OwnOrderUpdate)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *ordersClient) ListOrders(ctx context.Context, in *ListOrdersRequest, opts ...grpc.CallOption) (*ListOrdersResponse, error) {
	out := new(ListOrdersResponse)
	err := c.cc.Invoke(ctx, "/lssdrpc.orders/ListOrders", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// OrdersServer is the server API for Orders service.
type OrdersServer interface {
	// Places an order to the orderbook, you must have already enabled the involved trading pair.
	//
	// NOTE: After the order is matched, lssd will perform the swap automatically, so, your lnd
	// needs to have a channel with enough coins to our hub.
	PlaceOrder(context.Context, *PlaceOrderRequest) (*PlaceOrderResponse, error)
	// Cancels an existing order.
	CancelOrder(context.Context, *CancelOrderRequest) (*CancelOrderResponse, error)
	// Subscribe to events related to the orders in the orderbook.
	// Order added, removed will be delivered via this stream.
	SubscribeOrders(*SubscribeOrdersRequest, Orders_SubscribeOrdersServer) error
	// Subscribe to events related to the own oroders in the orderbook.
	// Order added, changed, removed will be delivered via this stream.
	SubscribeOwnOrders(*SubscribeOrdersRequest, Orders_SubscribeOwnOrdersServer) error
	// List the available order on the orderbook.
	ListOrders(context.Context, *ListOrdersRequest) (*ListOrdersResponse, error)
}

// UnimplementedOrdersServer can be embedded to have forward compatible implementations.
type UnimplementedOrdersServer struct {
}

func (*UnimplementedOrdersServer) PlaceOrder(ctx context.Context, req *PlaceOrderRequest) (*PlaceOrderResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PlaceOrder not implemented")
}
func (*UnimplementedOrdersServer) CancelOrder(ctx context.Context, req *CancelOrderRequest) (*CancelOrderResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CancelOrder not implemented")
}
func (*UnimplementedOrdersServer) SubscribeOrders(req *SubscribeOrdersRequest, srv Orders_SubscribeOrdersServer) error {
	return status.Errorf(codes.Unimplemented, "method SubscribeOrders not implemented")
}
func (*UnimplementedOrdersServer) SubscribeOwnOrders(req *SubscribeOrdersRequest, srv Orders_SubscribeOwnOrdersServer) error {
	return status.Errorf(codes.Unimplemented, "method SubscribeOwnOrders not implemented")
}
func (*UnimplementedOrdersServer) ListOrders(ctx context.Context, req *ListOrdersRequest) (*ListOrdersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListOrders not implemented")
}

func RegisterOrdersServer(s *grpc.Server, srv OrdersServer) {
	s.RegisterService(&_Orders_serviceDesc, srv)
}

func _Orders_PlaceOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PlaceOrderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrdersServer).PlaceOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lssdrpc.orders/PlaceOrder",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrdersServer).PlaceOrder(ctx, req.(*PlaceOrderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Orders_CancelOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CancelOrderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrdersServer).CancelOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lssdrpc.orders/CancelOrder",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrdersServer).CancelOrder(ctx, req.(*CancelOrderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Orders_SubscribeOrders_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscribeOrdersRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(OrdersServer).SubscribeOrders(m, &ordersSubscribeOrdersServer{stream})
}

type Orders_SubscribeOrdersServer interface {
	Send(*OrderUpdate) error
	grpc.ServerStream
}

type ordersSubscribeOrdersServer struct {
	grpc.ServerStream
}

func (x *ordersSubscribeOrdersServer) Send(m *OrderUpdate) error {
	return x.ServerStream.SendMsg(m)
}

func _Orders_SubscribeOwnOrders_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscribeOrdersRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(OrdersServer).SubscribeOwnOrders(m, &ordersSubscribeOwnOrdersServer{stream})
}

type Orders_SubscribeOwnOrdersServer interface {
	Send(*OwnOrderUpdate) error
	grpc.ServerStream
}

type ordersSubscribeOwnOrdersServer struct {
	grpc.ServerStream
}

func (x *ordersSubscribeOwnOrdersServer) Send(m *OwnOrderUpdate) error {
	return x.ServerStream.SendMsg(m)
}

func _Orders_ListOrders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListOrdersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrdersServer).ListOrders(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lssdrpc.orders/ListOrders",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrdersServer).ListOrders(ctx, req.(*ListOrdersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Orders_serviceDesc = grpc.ServiceDesc{
	ServiceName: "lssdrpc.orders",
	HandlerType: (*OrdersServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "PlaceOrder",
			Handler:    _Orders_PlaceOrder_Handler,
		},
		{
			MethodName: "CancelOrder",
			Handler:    _Orders_CancelOrder_Handler,
		},
		{
			MethodName: "ListOrders",
			Handler:    _Orders_ListOrders_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SubscribeOrders",
			Handler:       _Orders_SubscribeOrders_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SubscribeOwnOrders",
			Handler:       _Orders_SubscribeOwnOrders_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "lssdrpc.proto",
}

// SwapsClient is the client API for Swaps service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type SwapsClient interface {
	SubscribeSwaps(ctx context.Context, in *SubscribeSwapsRequest, opts ...grpc.CallOption) (Swaps_SubscribeSwapsClient, error)
}

type swapsClient struct {
	cc grpc.ClientConnInterface
}

func NewSwapsClient(cc grpc.ClientConnInterface) SwapsClient {
	return &swapsClient{cc}
}

func (c *swapsClient) SubscribeSwaps(ctx context.Context, in *SubscribeSwapsRequest, opts ...grpc.CallOption) (Swaps_SubscribeSwapsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Swaps_serviceDesc.Streams[0], "/lssdrpc.swaps/SubscribeSwaps", opts...)
	if err != nil {
		return nil, err
	}
	x := &swapsSubscribeSwapsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Swaps_SubscribeSwapsClient interface {
	Recv() (*SwapResult, error)
	grpc.ClientStream
}

type swapsSubscribeSwapsClient struct {
	grpc.ClientStream
}

func (x *swapsSubscribeSwapsClient) Recv() (*SwapResult, error) {
	m := new(SwapResult)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// SwapsServer is the server API for Swaps service.
type SwapsServer interface {
	SubscribeSwaps(*SubscribeSwapsRequest, Swaps_SubscribeSwapsServer) error
}

// UnimplementedSwapsServer can be embedded to have forward compatible implementations.
type UnimplementedSwapsServer struct {
}

func (*UnimplementedSwapsServer) SubscribeSwaps(req *SubscribeSwapsRequest, srv Swaps_SubscribeSwapsServer) error {
	return status.Errorf(codes.Unimplemented, "method SubscribeSwaps not implemented")
}

func RegisterSwapsServer(s *grpc.Server, srv SwapsServer) {
	s.RegisterService(&_Swaps_serviceDesc, srv)
}

func _Swaps_SubscribeSwaps_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscribeSwapsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(SwapsServer).SubscribeSwaps(m, &swapsSubscribeSwapsServer{stream})
}

type Swaps_SubscribeSwapsServer interface {
	Send(*SwapResult) error
	grpc.ServerStream
}

type swapsSubscribeSwapsServer struct {
	grpc.ServerStream
}

func (x *swapsSubscribeSwapsServer) Send(m *SwapResult) error {
	return x.ServerStream.SendMsg(m)
}

var _Swaps_serviceDesc = grpc.ServiceDesc{
	ServiceName: "lssdrpc.swaps",
	HandlerType: (*SwapsServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SubscribeSwaps",
			Handler:       _Swaps_SubscribeSwaps_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "lssdrpc.proto",
}

// RentingClient is the client API for Renting service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type RentingClient interface {
	GenerateRentChannelInvoice(ctx context.Context, in *GenerateInvoiceToRentChannelCommand, opts ...grpc.CallOption) (*GenerateInvoiceToRentChannelResponse, error)
	RentChannel(ctx context.Context, in *RentChannelCommand, opts ...grpc.CallOption) (*RentChannelResponse, error)
	GetChannelStatus(ctx context.Context, in *GetChannelStatusCommand, opts ...grpc.CallOption) (*GetChannelStatusResponse, error)
	GetFeeToRentChannel(ctx context.Context, in *GetFeeToRentChannelCommand, opts ...grpc.CallOption) (*GetFeeToRentChannelResponse, error)
}

type rentingClient struct {
	cc grpc.ClientConnInterface
}

func NewRentingClient(cc grpc.ClientConnInterface) RentingClient {
	return &rentingClient{cc}
}

func (c *rentingClient) GenerateRentChannelInvoice(ctx context.Context, in *GenerateInvoiceToRentChannelCommand, opts ...grpc.CallOption) (*GenerateInvoiceToRentChannelResponse, error) {
	out := new(GenerateInvoiceToRentChannelResponse)
	err := c.cc.Invoke(ctx, "/lssdrpc.renting/GenerateRentChannelInvoice", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rentingClient) RentChannel(ctx context.Context, in *RentChannelCommand, opts ...grpc.CallOption) (*RentChannelResponse, error) {
	out := new(RentChannelResponse)
	err := c.cc.Invoke(ctx, "/lssdrpc.renting/RentChannel", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rentingClient) GetChannelStatus(ctx context.Context, in *GetChannelStatusCommand, opts ...grpc.CallOption) (*GetChannelStatusResponse, error) {
	out := new(GetChannelStatusResponse)
	err := c.cc.Invoke(ctx, "/lssdrpc.renting/GetChannelStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rentingClient) GetFeeToRentChannel(ctx context.Context, in *GetFeeToRentChannelCommand, opts ...grpc.CallOption) (*GetFeeToRentChannelResponse, error) {
	out := new(GetFeeToRentChannelResponse)
	err := c.cc.Invoke(ctx, "/lssdrpc.renting/GetFeeToRentChannel", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RentingServer is the server API for Renting service.
type RentingServer interface {
	GenerateRentChannelInvoice(context.Context, *GenerateInvoiceToRentChannelCommand) (*GenerateInvoiceToRentChannelResponse, error)
	RentChannel(context.Context, *RentChannelCommand) (*RentChannelResponse, error)
	GetChannelStatus(context.Context, *GetChannelStatusCommand) (*GetChannelStatusResponse, error)
	GetFeeToRentChannel(context.Context, *GetFeeToRentChannelCommand) (*GetFeeToRentChannelResponse, error)
}

// UnimplementedRentingServer can be embedded to have forward compatible implementations.
type UnimplementedRentingServer struct {
}

func (*UnimplementedRentingServer) GenerateRentChannelInvoice(ctx context.Context, req *GenerateInvoiceToRentChannelCommand) (*GenerateInvoiceToRentChannelResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GenerateRentChannelInvoice not implemented")
}
func (*UnimplementedRentingServer) RentChannel(ctx context.Context, req *RentChannelCommand) (*RentChannelResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RentChannel not implemented")
}
func (*UnimplementedRentingServer) GetChannelStatus(ctx context.Context, req *GetChannelStatusCommand) (*GetChannelStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetChannelStatus not implemented")
}
func (*UnimplementedRentingServer) GetFeeToRentChannel(ctx context.Context, req *GetFeeToRentChannelCommand) (*GetFeeToRentChannelResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetFeeToRentChannel not implemented")
}

func RegisterRentingServer(s *grpc.Server, srv RentingServer) {
	s.RegisterService(&_Renting_serviceDesc, srv)
}

func _Renting_GenerateRentChannelInvoice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenerateInvoiceToRentChannelCommand)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RentingServer).GenerateRentChannelInvoice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lssdrpc.renting/GenerateRentChannelInvoice",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RentingServer).GenerateRentChannelInvoice(ctx, req.(*GenerateInvoiceToRentChannelCommand))
	}
	return interceptor(ctx, in, info, handler)
}

func _Renting_RentChannel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RentChannelCommand)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RentingServer).RentChannel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lssdrpc.renting/RentChannel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RentingServer).RentChannel(ctx, req.(*RentChannelCommand))
	}
	return interceptor(ctx, in, info, handler)
}

func _Renting_GetChannelStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetChannelStatusCommand)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RentingServer).GetChannelStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lssdrpc.renting/GetChannelStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RentingServer).GetChannelStatus(ctx, req.(*GetChannelStatusCommand))
	}
	return interceptor(ctx, in, info, handler)
}

func _Renting_GetFeeToRentChannel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetFeeToRentChannelCommand)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RentingServer).GetFeeToRentChannel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lssdrpc.renting/GetFeeToRentChannel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RentingServer).GetFeeToRentChannel(ctx, req.(*GetFeeToRentChannelCommand))
	}
	return interceptor(ctx, in, info, handler)
}

var _Renting_serviceDesc = grpc.ServiceDesc{
	ServiceName: "lssdrpc.renting",
	HandlerType: (*RentingServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GenerateRentChannelInvoice",
			Handler:    _Renting_GenerateRentChannelInvoice_Handler,
		},
		{
			MethodName: "RentChannel",
			Handler:    _Renting_RentChannel_Handler,
		},
		{
			MethodName: "GetChannelStatus",
			Handler:    _Renting_GetChannelStatus_Handler,
		},
		{
			MethodName: "GetFeeToRentChannel",
			Handler:    _Renting_GetFeeToRentChannel_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "lssdrpc.proto",
}
